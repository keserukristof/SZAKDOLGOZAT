{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-react-scheduler\n * Generated: 2020-03-04\n * Version: 2.5.0\n * License: https://js.devexpress.com/Licensing\n */\nimport { createElement, PureComponent, Fragment, createRef, memo, useRef, useState, useCallback, useEffect } from 'react';\nimport { Plugin, Getter, Template, TemplatePlaceholder, PluginHost, TemplateConnector, Action, createStateHelper, DragDropProvider as DragDropProvider$1, DropTarget, DragSource } from '@devexpress/dx-react-core';\nimport { formatDateTimeGetter, appointments, computed, availableViews, VERTICAL_GROUP_ORIENTATION, HORIZONTAL_GROUP_ORIENTATION, startViewDate, endViewDate, VIEW_TYPES, viewCellsData, calculateWeekDateIntervals, monthCellsData, calculateMonthDateIntervals, viewBoundText, POSITION_START, POSITION_END, isTimeTableElementsMetaActual, calculateRectByDateAndGroupIntervals, getAppointmentStyle, isAllDayElementsMetaActual, HORIZONTAL_TYPE, getHorizontalRectByAppointmentData, VERTICAL_TYPE, getVerticalRectByAppointmentData, allDayCells, calculateAllDayDateIntervals, changeCurrentDate, setCurrentViewName, preCommitChanges, startEditAppointment, stopEditAppointment, changeAppointment, cancelChanges, RECURRENCE_EDIT_SCOPE, changedAppointmentById, addAppointment, cancelAddedAppointment, TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, getAppointmentResources, OPEN_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, DELETE_COMMAND_BUTTON, setAppointmentMeta, TOGGLE_APPOINTMENT_FORM_VISIBILITY, callActionIfExists, isAllDayCell, checkMultipleResourceFields, setAppointmentData, autoScroll, cellIndex, cellData, cellType, calculateInsidePart, intervalDuration, calculateAppointmentTimeBoundaries, calculateAppointmentGroups, appointmentDragged, calculateDraftAppointments, RESIZE_TOP, RESIZE_BOTTOM, validateResources, addResourcesToAppointments, convertResourcesToPlain, toggleExpandedGroups, HORIZONTAL_VIEW_LEFT_OFFSET, VERTICAL_VIEW_LEFT_OFFSET, isMonthCell, getCurrentTimeIndicatorTop, isCellShaded, isShadedAppointment, expandViewCellsDataWithGroups, getGroupsFromResources, sortFilteredResources, filterResourcesByGrouping, updateGroupingWithMainResource, expandGroups } from '@devexpress/dx-scheduler-core';\nimport { memoize, createClickHandlers, getMessagesFormatter } from '@devexpress/dx-core';\nimport moment from 'moment';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return _extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  _extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nvar SchedulerCoreBase = /*#__PURE__*/function (_super) {\n  __extends(SchedulerCoreBase, _super);\n\n  function SchedulerCoreBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.formatDateTimeGetter = memoize(function (locale) {\n      return formatDateTimeGetter(locale);\n    });\n    return _this;\n  }\n\n  SchedulerCoreBase.prototype.render = function () {\n    var _a = this.props,\n        data = _a.data,\n        Root = _a.rootComponent,\n        locale = _a.locale,\n        height = _a.height,\n        firstDayOfWeek = _a.firstDayOfWeek;\n    return createElement(Plugin, {\n      name: \"SchedulerCore\"\n    }, createElement(Getter, {\n      name: \"appointments\",\n      value: appointments(data)\n    }), createElement(Getter, {\n      name: \"formatDate\",\n      value: formatDateTimeGetter(locale)\n    }), createElement(Getter, {\n      name: \"firstDayOfWeek\",\n      value: firstDayOfWeek\n    }), createElement(Getter, {\n      name: \"locale\",\n      value: locale\n    }), createElement(Template, {\n      name: \"root\"\n    }, createElement(Root, {\n      height: height\n    }, createElement(TemplatePlaceholder, {\n      name: \"schedulerRoot\"\n    }), createElement(TemplatePlaceholder, {\n      name: \"header\"\n    }), createElement(TemplatePlaceholder, {\n      name: \"body\"\n    }), createElement(TemplatePlaceholder, {\n      name: \"footer\"\n    }))));\n  };\n\n  return SchedulerCoreBase;\n}(PureComponent);\n/***\r\n * The Scheduler is a root container component designed to process\r\n * and display the specified data. The Scheduler's functionality\r\n * (data visualization and processing) is implemented in several plugins\r\n * specified as child components.\r\n * */\n\n\nvar SchedulerCore = SchedulerCoreBase;\n\nvar SchedulerBase = function SchedulerBase(_a) {\n  var data = _a.data,\n      rootComponent = _a.rootComponent,\n      children = _a.children,\n      locale = _a.locale,\n      height = _a.height,\n      firstDayOfWeek = _a.firstDayOfWeek;\n  return createElement(PluginHost, null, createElement(SchedulerCore, {\n    data: data,\n    rootComponent: rootComponent,\n    locale: locale,\n    height: height,\n    firstDayOfWeek: firstDayOfWeek\n  }), children);\n};\n\nSchedulerBase.defaultProps = {\n  data: [],\n  locale: 'en-US',\n  height: 'auto',\n  firstDayOfWeek: 0\n}; // tslint:disable: max-line-length\n\n/***\r\n * The Scheduler is a root container component designed to process\r\n * and display the specified data. The Scheduler’s functionality\r\n * (data visualization and processing) is implemented in several plugins specified as child components.\r\n * */\n\nvar Scheduler = SchedulerBase;\n\nvar CellPlaceholder = function CellPlaceholder(params) {\n  return createElement(TemplatePlaceholder, {\n    name: \"cell\",\n    params: params\n  });\n};\n\nvar TimeTableAppointmentLayer = function TimeTableAppointmentLayer() {\n  return createElement(TemplatePlaceholder, {\n    name: \"timeTableAppointmentLayer\"\n  });\n};\n\nvar startViewDateBaseComputed = function startViewDateBaseComputed(_a) {\n  var viewCellsData = _a.viewCellsData;\n  return startViewDate(viewCellsData);\n};\n\nvar endViewDateBaseComputed = function endViewDateBaseComputed(_a) {\n  var viewCellsData = _a.viewCellsData;\n  return endViewDate(viewCellsData);\n};\n\nvar TimeTablePlaceholder = function TimeTablePlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"timeTable\"\n  });\n};\n\nvar DayScalePlaceholder = function DayScalePlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"dayScale\"\n  });\n};\n\nvar DayScaleEmptyCellPlaceholder = function DayScaleEmptyCellPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"dayScaleEmptyCell\"\n  });\n};\n\nvar GroupingPanelPlaceholder = function GroupingPanelPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"groupingPanel\"\n  });\n};\n\nvar BasicViewBase = /*#__PURE__*/function (_super) {\n  __extends(BasicViewBase, _super);\n\n  function BasicViewBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      timeTableElementsMeta: {},\n      scrollingStrategy: {\n        topBoundary: 0,\n        bottomBoundary: 0,\n        leftBoundary: 0,\n        rightBoundary: 0,\n        changeVerticalScroll: function changeVerticalScroll() {\n          return undefined;\n        },\n        changeHorizontalScroll: function changeHorizontalScroll() {\n          return undefined;\n        }\n      },\n      previousTimeTableCell: null,\n      // The key has to be generated every time the TimeTableCell is updated to rerender TimeTable\n      // and, consequently, update timeTableElementsMeta\n      timeTableLayoutKey: 0\n    };\n    _this.scrollingStrategyComputed = memoize(function (viewName, scrollingStrategy) {\n      return function (getters) {\n        return computed(getters, viewName, function () {\n          return scrollingStrategy;\n        }, getters.scrollingStrategy);\n      };\n    });\n    _this.timeTableElementsMetaComputed = memoize(function (viewName, timeTableElementsMeta) {\n      return function (getters) {\n        return computed(getters, viewName, function () {\n          return timeTableElementsMeta;\n        }, getters.timeTableElementsMeta);\n      };\n    });\n    _this.intervalCountComputed = memoize(function (viewName, intervalCount) {\n      return function (getters) {\n        return computed(getters, viewName, function () {\n          return intervalCount;\n        }, getters.intervalCount);\n      };\n    });\n    _this.cellDurationComputed = memoize(function (viewName, cellDuration) {\n      return function (getters) {\n        return computed(getters, viewName, function () {\n          return cellDuration;\n        }, getters.cellDuration);\n      };\n    });\n    _this.excludedDaysComputed = memoize(function (viewName, excludedDays) {\n      return function (getters) {\n        return computed(getters, viewName, function () {\n          return excludedDays;\n        }, getters.excludedDays);\n      };\n    });\n    _this.availableViewsComputed = memoize(function (viewName, viewDisplayName) {\n      return function (_a) {\n        var availableViews$1 = _a.availableViews;\n        return availableViews(availableViews$1, viewName, viewDisplayName);\n      };\n    });\n    _this.currentViewComputed = memoize(function (viewName, viewDisplayName, type) {\n      return function (_a) {\n        var currentView = _a.currentView;\n        return currentView && currentView.name !== viewName ? currentView : {\n          name: viewName,\n          type: type,\n          displayName: viewDisplayName\n        };\n      };\n    });\n\n    _this.endViewDateComputed = function (getters) {\n      var viewName = _this.props.name;\n      return computed(getters, viewName, endViewDateBaseComputed, getters.endViewDate);\n    };\n\n    _this.startViewDateComputed = function (getters) {\n      var viewName = _this.props.name;\n      return computed(getters, viewName, startViewDateBaseComputed, getters.startViewDate);\n    };\n\n    _this.viewCellsDataComputed = memoize(function (viewName, cellDuration, startDayHour, endDayHour, viewCellsDataBaseComputed) {\n      return function (getters) {\n        return computed(getters, viewName, viewCellsDataBaseComputed(cellDuration, startDayHour, endDayHour), getters.viewCellsData);\n      };\n    });\n    _this.timeTableAppointmentsComputed = memoize(function (viewName, cellDuration, calculateAppointmentsIntervals) {\n      return function (getters) {\n        return computed(getters, viewName, calculateAppointmentsIntervals(cellDuration), getters.timeTableAppointments);\n      };\n    });\n    _this.updateCellElementsMeta = memoize(function (cellElementsMeta) {\n      _this.setState({\n        timeTableElementsMeta: cellElementsMeta\n      });\n    });\n\n    _this.setScrollingStrategy = function (scrollingStrategy) {\n      _this.setState({\n        scrollingStrategy: scrollingStrategy\n      });\n    };\n\n    return _this;\n  }\n\n  BasicViewBase.getDerivedStateFromProps = function (props, state) {\n    if (props.timeTableCellComponent !== state.previousTimeTableCell) {\n      return _assign(_assign({}, state), {\n        previousTimeTableCell: props.timeTableCellComponent,\n        timeTableLayoutKey: Math.random()\n      });\n    }\n\n    return null;\n  };\n\n  BasicViewBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        viewName = _a.name,\n        intervalCount = _a.intervalCount,\n        displayName = _a.displayName,\n        type = _a.type,\n        excludedDays = _a.excludedDays,\n        cellDuration = _a.cellDuration,\n        startDayHour = _a.startDayHour,\n        endDayHour = _a.endDayHour,\n        viewCellsDataComputed = _a.viewCellsDataComputed,\n        calculateAppointmentsIntervals = _a.calculateAppointmentsIntervals,\n        dayScaleCellComponent = _a.dayScaleCellComponent,\n        dayScaleRowComponent = _a.dayScaleRowComponent,\n        DayScale = _a.dayScaleLayoutComponent,\n        TimeTableCell = _a.timeTableCellComponent,\n        TimeTableLayout = _a.timeTableLayoutComponent,\n        timeTableRowComponent = _a.timeTableRowComponent,\n        AppointmentLayer = _a.appointmentLayerComponent,\n        DayScaleEmptyCell = _a.dayScaleEmptyCellComponent,\n        layoutProps = _a.layoutProps,\n        Layout = _a.layoutComponent;\n    var _b = this.state,\n        timeTableElementsMeta = _b.timeTableElementsMeta,\n        scrollingStrategy = _b.scrollingStrategy,\n        timeTableLayoutKey = _b.timeTableLayoutKey;\n    var viewDisplayName = displayName || viewName;\n    return createElement(Plugin, {\n      name: \"basicView\"\n    }, createElement(Getter, {\n      name: \"availableViews\",\n      computed: this.availableViewsComputed(viewName, viewDisplayName)\n    }), createElement(Getter, {\n      name: \"currentView\",\n      computed: this.currentViewComputed(viewName, viewDisplayName, type)\n    }), createElement(Getter, {\n      name: \"intervalCount\",\n      computed: this.intervalCountComputed(viewName, intervalCount)\n    }), createElement(Getter, {\n      name: \"excludedDays\",\n      computed: this.excludedDaysComputed(viewName, excludedDays)\n    }), createElement(Getter, {\n      name: \"viewCellsData\",\n      computed: this.viewCellsDataComputed(viewName, cellDuration, startDayHour, endDayHour, viewCellsDataComputed)\n    }), createElement(Getter, {\n      name: \"startViewDate\",\n      computed: this.startViewDateComputed\n    }), createElement(Getter, {\n      name: \"endViewDate\",\n      computed: this.endViewDateComputed\n    }), createElement(Getter, {\n      name: \"cellDuration\",\n      computed: this.cellDurationComputed(viewName, cellDuration)\n    }), createElement(Getter, {\n      name: \"timeTableElementsMeta\",\n      computed: this.timeTableElementsMetaComputed(viewName, timeTableElementsMeta)\n    }), createElement(Getter, {\n      name: \"scrollingStrategy\",\n      computed: this.scrollingStrategyComputed(viewName, scrollingStrategy)\n    }), createElement(Getter, {\n      name: \"timeTableAppointments\",\n      computed: this.timeTableAppointmentsComputed(viewName, cellDuration, calculateAppointmentsIntervals)\n    }), createElement(Template, {\n      name: \"body\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var currentView = _a.currentView,\n            groupOrientation = _a.groupOrientation,\n            groups = _a.groups;\n        if (currentView.name !== viewName) return createElement(TemplatePlaceholder, null);\n        var isVerticalGrouping = (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(viewName)) === VERTICAL_GROUP_ORIENTATION;\n        return createElement(Layout, _assign({\n          dayScaleComponent: DayScalePlaceholder,\n          timeTableComponent: TimeTablePlaceholder,\n          setScrollingStrategy: _this.setScrollingStrategy,\n          groupingPanelComponent: isVerticalGrouping ? GroupingPanelPlaceholder : undefined,\n          groupingPanelSize: isVerticalGrouping ? groups === null || groups === void 0 ? void 0 : groups.length : 0,\n          dayScaleEmptyCellComponent: DayScaleEmptyCellPlaceholder\n        }, layoutProps, params));\n      });\n    }), createElement(Template, {\n      name: \"dayScale\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView,\n          viewCellsData = _a.viewCellsData,\n          formatDate = _a.formatDate,\n          groupByDate = _a.groupByDate,\n          groupOrientation = _a.groupOrientation;\n      if (currentView.name !== viewName) return createElement(TemplatePlaceholder, null);\n      var groupByDateEnabled = groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(viewName);\n      var isHorizontalGrouping = (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(viewName)) === HORIZONTAL_GROUP_ORIENTATION;\n      return createElement(DayScale, {\n        cellComponent: dayScaleCellComponent,\n        rowComponent: dayScaleRowComponent,\n        groupingPanelComponent: isHorizontalGrouping ? GroupingPanelPlaceholder : undefined,\n        cellsData: viewCellsData,\n        formatDate: formatDate,\n        groupedByDate: groupByDateEnabled\n      });\n    })), createElement(Template, {\n      name: \"cell\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var currentView = _a.currentView;\n        if (currentView.name !== viewName) return createElement(TemplatePlaceholder, {\n          params: params\n        });\n        return createElement(TimeTableCell, _assign({}, params));\n      });\n    }), createElement(Template, {\n      name: \"timeTable\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var formatDate = _a.formatDate,\n          currentView = _a.currentView,\n          viewCellsData = _a.viewCellsData;\n      if (currentView.name !== viewName) return createElement(TemplatePlaceholder, null);\n      return createElement(Fragment, null, createElement(TimeTableLayout, {\n        cellsData: viewCellsData,\n        rowComponent: timeTableRowComponent,\n        cellComponent: CellPlaceholder,\n        formatDate: formatDate,\n        setCellElementsMeta: _this.updateCellElementsMeta,\n        key: timeTableLayoutKey\n      }), createElement(AppointmentLayer, null, createElement(TimeTableAppointmentLayer, null)));\n    })), createElement(Template, {\n      name: \"dayScaleEmptyCell\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView;\n\n      if (currentView.name !== viewName || !DayScaleEmptyCell) {\n        return createElement(TemplatePlaceholder, null);\n      }\n\n      return createElement(DayScaleEmptyCell, null);\n    })));\n  };\n\n  return BasicViewBase;\n}(PureComponent);\n\nvar BasicView = BasicViewBase;\n\nvar viewCellsDataBaseComputed = function viewCellsDataBaseComputed(cellDuration, startDayHour, endDayHour) {\n  return function (_a) {\n    var currentDate = _a.currentDate,\n        intervalCount = _a.intervalCount;\n    return viewCellsData(currentDate, undefined, intervalCount, [], startDayHour, endDayHour, cellDuration, Date.now());\n  };\n};\n\nvar calculateAppointmentsIntervalsBaseComputed = function calculateAppointmentsIntervalsBaseComputed(cellDuration) {\n  return function (_a) {\n    var appointments = _a.appointments,\n        startViewDate = _a.startViewDate,\n        endViewDate = _a.endViewDate,\n        excludedDays = _a.excludedDays;\n    return calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  };\n};\n\nvar TimeScalePlaceholder = function TimeScalePlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"timeScale\"\n  });\n};\n\nvar DayViewBase = /*#__PURE__*/function (_super) {\n  __extends(DayViewBase, _super);\n\n  function DayViewBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayViewBase.prototype.render = function () {\n    var _a = this.props,\n        layoutComponent = _a.layoutComponent,\n        DayScaleEmptyCell = _a.dayScaleEmptyCellComponent,\n        TimeScale = _a.timeScaleLayoutComponent,\n        TimeScaleLabel = _a.timeScaleLabelComponent,\n        timeScaleTickCellComponent = _a.timeScaleTickCellComponent,\n        timeScaleTicksRowComponent = _a.timeScaleTicksRowComponent,\n        dayScaleLayoutComponent = _a.dayScaleLayoutComponent,\n        dayScaleCellComponent = _a.dayScaleCellComponent,\n        dayScaleRowComponent = _a.dayScaleRowComponent,\n        timeTableLayoutComponent = _a.timeTableLayoutComponent,\n        timeTableRowComponent = _a.timeTableRowComponent,\n        timeTableCellComponent = _a.timeTableCellComponent,\n        appointmentLayerComponent = _a.appointmentLayerComponent,\n        cellDuration = _a.cellDuration,\n        viewName = _a.name,\n        intervalCount = _a.intervalCount,\n        displayName = _a.displayName,\n        startDayHour = _a.startDayHour,\n        endDayHour = _a.endDayHour;\n    return createElement(Plugin, {\n      name: \"DayView\"\n    }, createElement(BasicView, {\n      viewCellsDataComputed: viewCellsDataBaseComputed,\n      type: VIEW_TYPES.DAY,\n      cellDuration: cellDuration,\n      name: viewName,\n      intervalCount: intervalCount,\n      displayName: displayName,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      calculateAppointmentsIntervals: calculateAppointmentsIntervalsBaseComputed,\n      dayScaleEmptyCellComponent: DayScaleEmptyCell,\n      dayScaleLayoutComponent: dayScaleLayoutComponent,\n      dayScaleCellComponent: dayScaleCellComponent,\n      dayScaleRowComponent: dayScaleRowComponent,\n      timeTableCellComponent: timeTableCellComponent,\n      timeTableLayoutComponent: timeTableLayoutComponent,\n      timeTableRowComponent: timeTableRowComponent,\n      appointmentLayerComponent: appointmentLayerComponent,\n      layoutComponent: layoutComponent,\n      layoutProps: {\n        timeScaleComponent: TimeScalePlaceholder\n      }\n    }), createElement(Template, {\n      name: \"timeScale\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView,\n          viewCellsData = _a.viewCellsData,\n          groups = _a.groups,\n          formatDate = _a.formatDate,\n          getGroupOrientation = _a.groupOrientation;\n      if (currentView.name !== viewName) return createElement(TemplatePlaceholder, null);\n      var groupOrientation = getGroupOrientation === null || getGroupOrientation === void 0 ? void 0 : getGroupOrientation(viewName);\n      return createElement(TimeScale, {\n        labelComponent: TimeScaleLabel,\n        tickCellComponent: timeScaleTickCellComponent,\n        rowComponent: timeScaleTicksRowComponent,\n        cellsData: viewCellsData,\n        formatDate: formatDate,\n        groups: groups,\n        groupOrientation: groupOrientation\n      });\n    })));\n  };\n\n  DayViewBase.defaultProps = {\n    name: 'Day',\n    startDayHour: 0,\n    endDayHour: 24,\n    cellDuration: 30,\n    intervalCount: 1\n  };\n  DayViewBase.components = {\n    layoutComponent: 'Layout',\n    layoutContainer: 'LayoutContainer',\n    appointmentLayerComponent: 'AppointmentLayer',\n    dayScaleEmptyCellComponent: 'DayScaleEmptyCell',\n    timeScaleLayoutComponent: 'TimeScaleLayout',\n    timeScaleLabelComponent: 'TimeScaleLabel',\n    timeScaleTickCellComponent: 'TimeScaleTickCell',\n    timeScaleTicksRowComponent: 'TimeScaleTicksRow',\n    dayScaleLayoutComponent: 'DayScaleLayout',\n    dayScaleCellComponent: 'DayScaleCell',\n    dayScaleRowComponent: 'DayScaleRow',\n    timeTableContainerComponent: 'TimeTableContainer',\n    timeTableLayoutComponent: 'TimeTableLayout',\n    timeTableCellComponent: 'TimeTableCell',\n    timeTableRowComponent: 'TimeTableRow'\n  };\n  return DayViewBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/*** A plugin that renders Scheduler data for a day. This plugin arranges appointments from top to bottom.\r\n * If their time intervals overlap, their width is decreased and they are placed next to each other.\r\n * */\n\n\nvar DayView = DayViewBase;\nvar DAYS_IN_WEEK = 7;\n\nvar viewCellsDataBaseComputed$1 = function viewCellsDataBaseComputed$1(cellDuration, startDayHour, endDayHour) {\n  return function (_a) {\n    var firstDayOfWeek = _a.firstDayOfWeek,\n        intervalCount = _a.intervalCount,\n        excludedDays = _a.excludedDays,\n        currentDate = _a.currentDate;\n    return viewCellsData(currentDate, firstDayOfWeek, intervalCount * DAYS_IN_WEEK, excludedDays, startDayHour, endDayHour, cellDuration, Date.now());\n  };\n};\n\nvar calculateAppointmentsIntervalsBaseComputed$1 = function calculateAppointmentsIntervalsBaseComputed$1(cellDuration) {\n  return function (_a) {\n    var appointments = _a.appointments,\n        startViewDate = _a.startViewDate,\n        endViewDate = _a.endViewDate,\n        excludedDays = _a.excludedDays;\n    return calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  };\n};\n\nvar TimeScalePlaceholder$1 = function TimeScalePlaceholder$1() {\n  return createElement(TemplatePlaceholder, {\n    name: \"timeScale\"\n  });\n};\n\nvar WeekViewBase = /*#__PURE__*/function (_super) {\n  __extends(WeekViewBase, _super);\n\n  function WeekViewBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  WeekViewBase.prototype.render = function () {\n    var _a = this.props,\n        layoutComponent = _a.layoutComponent,\n        dayScaleEmptyCellComponent = _a.dayScaleEmptyCellComponent,\n        TimeScale = _a.timeScaleLayoutComponent,\n        TimeScaleLabel = _a.timeScaleLabelComponent,\n        timeScaleTickCellComponent = _a.timeScaleTickCellComponent,\n        timeScaleTicksRowComponent = _a.timeScaleTicksRowComponent,\n        dayScaleLayoutComponent = _a.dayScaleLayoutComponent,\n        dayScaleCellComponent = _a.dayScaleCellComponent,\n        dayScaleRowComponent = _a.dayScaleRowComponent,\n        timeTableLayoutComponent = _a.timeTableLayoutComponent,\n        timeTableRowComponent = _a.timeTableRowComponent,\n        timeTableCellComponent = _a.timeTableCellComponent,\n        cellDuration = _a.cellDuration,\n        excludedDays = _a.excludedDays,\n        viewName = _a.name,\n        appointmentLayerComponent = _a.appointmentLayerComponent,\n        intervalCount = _a.intervalCount,\n        displayName = _a.displayName,\n        startDayHour = _a.startDayHour,\n        endDayHour = _a.endDayHour;\n    return createElement(Plugin, {\n      name: \"WeekView\"\n    }, createElement(BasicView, {\n      viewCellsDataComputed: viewCellsDataBaseComputed$1,\n      type: VIEW_TYPES.WEEK,\n      cellDuration: cellDuration,\n      name: viewName,\n      intervalCount: intervalCount,\n      displayName: displayName,\n      startDayHour: startDayHour,\n      endDayHour: endDayHour,\n      excludedDays: excludedDays,\n      calculateAppointmentsIntervals: calculateAppointmentsIntervalsBaseComputed$1,\n      dayScaleEmptyCellComponent: dayScaleEmptyCellComponent,\n      dayScaleLayoutComponent: dayScaleLayoutComponent,\n      dayScaleCellComponent: dayScaleCellComponent,\n      dayScaleRowComponent: dayScaleRowComponent,\n      timeTableCellComponent: timeTableCellComponent,\n      timeTableLayoutComponent: timeTableLayoutComponent,\n      timeTableRowComponent: timeTableRowComponent,\n      appointmentLayerComponent: appointmentLayerComponent,\n      layoutComponent: layoutComponent,\n      layoutProps: {\n        timeScaleComponent: TimeScalePlaceholder$1\n      }\n    }), createElement(Template, {\n      name: \"timeScale\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView,\n          viewCellsData = _a.viewCellsData,\n          getGroupOrientation = _a.groupOrientation,\n          groups = _a.groups,\n          formatDate = _a.formatDate;\n      if (currentView.name !== viewName) return createElement(TemplatePlaceholder, null);\n      var groupOrientation = getGroupOrientation === null || getGroupOrientation === void 0 ? void 0 : getGroupOrientation(viewName);\n      return createElement(TimeScale, {\n        labelComponent: TimeScaleLabel,\n        tickCellComponent: timeScaleTickCellComponent,\n        rowComponent: timeScaleTicksRowComponent,\n        cellsData: viewCellsData,\n        formatDate: formatDate,\n        groups: groups,\n        groupOrientation: groupOrientation\n      });\n    })));\n  };\n\n  WeekViewBase.defaultProps = {\n    startDayHour: 0,\n    endDayHour: 24,\n    cellDuration: 30,\n    intervalCount: 1,\n    excludedDays: [],\n    name: 'Week'\n  };\n  WeekViewBase.components = {\n    layoutComponent: 'Layout',\n    layoutContainerComponent: 'LayoutContainer',\n    appointmentLayerComponent: 'AppointmentLayer',\n    dayScaleEmptyCellComponent: 'DayScaleEmptyCell',\n    timeScaleLayoutComponent: 'TimeScaleLayout',\n    timeScaleLabelComponent: 'TimeScaleLabel',\n    timeScaleTickCellComponent: 'TimeScaleTickCell',\n    timeScaleTicksRowComponent: 'TimeScaleTicksRow',\n    dayScaleLayoutComponent: 'DayScaleLayout',\n    dayScaleCellComponent: 'DayScaleCell',\n    dayScaleRowComponent: 'DayScaleRow',\n    timeTableContainerComponent: 'TimeTableContainer',\n    timeTableLayoutComponent: 'TimeTableLayout',\n    timeTableCellComponent: 'TimeTableCell',\n    timeTableRowComponent: 'TimeTableRow'\n  };\n  return WeekViewBase;\n}(PureComponent); // tslint:disable: max-line-length\n\n/***\r\n * A plugin that renders the Scheduler's week view. This plugin arranges appointments from top to bottom.\r\n * If their time intervals overlap, their width is decreased and they are placed next to each other.\r\n * */\n\n\nvar WeekView = WeekViewBase;\n\nvar viewCellsDataBaseComputed$2 = function viewCellsDataBaseComputed$2(cellDuration, startDayHour, endDayHour) {\n  return function (_a) {\n    var currentDate = _a.currentDate,\n        firstDayOfWeek = _a.firstDayOfWeek,\n        intervalCount = _a.intervalCount;\n    return monthCellsData(currentDate, firstDayOfWeek, intervalCount, Date.now());\n  };\n};\n\nvar calculateAppointmentsIntervalsBaseComputed$2 = function calculateAppointmentsIntervalsBaseComputed$2(cellDuration) {\n  return function (_a) {\n    var appointments = _a.appointments,\n        startViewDate = _a.startViewDate,\n        endViewDate = _a.endViewDate,\n        excludedDays = _a.excludedDays;\n    return calculateMonthDateIntervals(appointments, startViewDate, endViewDate);\n  };\n};\n\nvar MonthViewBase = /*#__PURE__*/function (_super) {\n  __extends(MonthViewBase, _super);\n\n  function MonthViewBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  MonthViewBase.prototype.render = function () {\n    var _a = this.props,\n        layoutComponent = _a.layoutComponent,\n        dayScaleEmptyCellComponent = _a.dayScaleEmptyCellComponent,\n        dayScaleLayoutComponent = _a.dayScaleLayoutComponent,\n        dayScaleCellComponent = _a.dayScaleCellComponent,\n        dayScaleRowComponent = _a.dayScaleRowComponent,\n        timeTableLayoutComponent = _a.timeTableLayoutComponent,\n        timeTableRowComponent = _a.timeTableRowComponent,\n        timeTableCellComponent = _a.timeTableCellComponent,\n        appointmentLayerComponent = _a.appointmentLayerComponent,\n        viewName = _a.name,\n        intervalCount = _a.intervalCount,\n        displayName = _a.displayName;\n    return createElement(Plugin, {\n      name: \"MonthView\"\n    }, createElement(BasicView, {\n      viewCellsDataComputed: viewCellsDataBaseComputed$2,\n      type: VIEW_TYPES.MONTH,\n      name: viewName,\n      intervalCount: intervalCount,\n      displayName: displayName,\n      calculateAppointmentsIntervals: calculateAppointmentsIntervalsBaseComputed$2,\n      dayScaleEmptyCellComponent: dayScaleEmptyCellComponent,\n      dayScaleLayoutComponent: dayScaleLayoutComponent,\n      dayScaleCellComponent: dayScaleCellComponent,\n      dayScaleRowComponent: dayScaleRowComponent,\n      timeTableCellComponent: timeTableCellComponent,\n      timeTableLayoutComponent: timeTableLayoutComponent,\n      timeTableRowComponent: timeTableRowComponent,\n      appointmentLayerComponent: appointmentLayerComponent,\n      layoutComponent: layoutComponent\n    }));\n  };\n\n  MonthViewBase.defaultProps = {\n    intervalCount: 1,\n    name: 'Month'\n  };\n  MonthViewBase.components = {\n    layoutComponent: 'Layout',\n    appointmentLayerComponent: 'AppointmentLayer',\n    dayScaleEmptyCellComponent: 'DayScaleEmptyCell',\n    dayScaleLayoutComponent: 'DayScaleLayout',\n    dayScaleCellComponent: 'DayScaleCell',\n    dayScaleRowComponent: 'DayScaleRow',\n    timeTableContainerComponent: 'TimeTableContainer',\n    timeTableLayoutComponent: 'TimeTableLayout',\n    timeTableCellComponent: 'TimeTableCell',\n    timeTableRowComponent: 'TimeTableRow'\n  };\n  return MonthViewBase;\n}(PureComponent); // tslint:disable: max-line-length\n\n/***\r\n * A plugin that renders Scheduler data for a month. This plugin arranges appointments from left to right.\r\n * An appointment's size depends on its duration in days.\r\n * However, it occupies the entire day cell if an appointment lasts only for several hours or minutes.\r\n * The time scale and all-day panel are not available in this view.\r\n * */\n\n\nvar MonthView = MonthViewBase;\n\nvar ToolbarBase = /*#__PURE__*/function (_super) {\n  __extends(ToolbarBase, _super);\n\n  function ToolbarBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ToolbarBase.prototype.render = function () {\n    var _a = this.props,\n        Root = _a.rootComponent,\n        FlexibleSpaceComponent = _a.flexibleSpaceComponent;\n    return createElement(Plugin, {\n      name: \"Toolbar\"\n    }, createElement(Template, {\n      name: \"header\"\n    }, createElement(Root, null, createElement(TemplatePlaceholder, {\n      name: \"toolbarContent\"\n    })), createElement(TemplatePlaceholder, null)), createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(FlexibleSpaceComponent, null)));\n  };\n\n  ToolbarBase.components = {\n    rootComponent: 'Root',\n    flexibleSpaceComponent: 'FlexibleSpace'\n  };\n  return ToolbarBase;\n}(PureComponent);\n/** A plugin that renders the Scheduler's toolbar. */\n\n\nvar Toolbar = ToolbarBase;\nvar pluginDependencies = [{\n  name: 'Toolbar'\n}, {\n  name: 'ViewState'\n}];\n\nvar navigate = function navigate(action, currentView, intervalCount) {\n  return function (direction, nextDate) {\n    return action({\n      direction: direction,\n      nextDate: nextDate,\n      amount: intervalCount,\n      step: currentView.type\n    });\n  };\n};\n\nvar DateNavigatorBase = /*#__PURE__*/function (_super) {\n  __extends(DateNavigatorBase, _super);\n\n  function DateNavigatorBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      visible: false\n    };\n\n    _this.setRootRef = function (target) {\n      _this.target = target;\n    };\n\n    _this.handleVisibilityToggle = function () {\n      _this.setState(function (prevState) {\n        return {\n          visible: !prevState.visible\n        };\n      });\n    };\n\n    _this.handleHide = function () {\n      _this.setState({\n        visible: false\n      });\n    };\n\n    _this.navigateAction = memoize(function (changeCurrentDate, currentView, intervalCount, navigateAction) {\n      return navigateAction(changeCurrentDate, currentView, intervalCount);\n    });\n    return _this;\n  }\n\n  DateNavigatorBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        Root = _a.rootComponent,\n        Overlay = _a.overlayComponent,\n        OpenButton = _a.openButtonComponent,\n        NavigationButton = _a.navigationButtonComponent,\n        Calendar = _a.calendarComponent,\n        CalendarRow = _a.calendarRowComponent,\n        CalendarCell = _a.calendarCellComponent,\n        CalendarHeaderRow = _a.calendarHeaderRowComponent,\n        CalendarHeaderCell = _a.calendarHeaderCellComponent,\n        CalendarText = _a.calendarTextComponent,\n        CalendarNavigationButton = _a.calendarNavigationButtonComponent,\n        CalendarNavigator = _a.calendarNavigatorComponent;\n    var visible = this.state.visible;\n    return createElement(Plugin, {\n      name: \"DateNavigator\",\n      dependencies: pluginDependencies\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var currentDate = _a.currentDate,\n          startViewDate = _a.startViewDate,\n          endViewDate = _a.endViewDate,\n          firstDayOfWeek = _a.firstDayOfWeek,\n          currentView = _a.currentView,\n          intervalCount = _a.intervalCount,\n          formatDate = _a.formatDate;\n      var changeCurrentDate = _b.changeCurrentDate;\n\n      var navigateAction = _this.navigateAction(changeCurrentDate, currentView, intervalCount, navigate);\n\n      var calendarDateChanged = function calendarDateChanged(nextDate) {\n        navigateAction(undefined, nextDate);\n\n        _this.handleHide();\n      };\n\n      var navigatorText = viewBoundText(startViewDate, endViewDate, currentView.type, currentDate, intervalCount, formatDate);\n      return createElement(Fragment, null, createElement(Root, {\n        navigationButtonComponent: NavigationButton,\n        openButtonComponent: OpenButton,\n        navigatorText: navigatorText,\n        rootRef: _this.setRootRef,\n        onVisibilityToggle: _this.handleVisibilityToggle,\n        onNavigate: navigateAction\n      }), createElement(Overlay, {\n        visible: visible,\n        target: _this.target,\n        onHide: _this.handleHide\n      }, createElement(Calendar, {\n        selectedDate: currentDate,\n        firstDayOfWeek: firstDayOfWeek,\n        getCells: monthCellsData,\n        textComponent: CalendarText,\n        navigationButtonComponent: CalendarNavigationButton,\n        rowComponent: CalendarRow,\n        cellComponent: CalendarCell,\n        headerRowComponent: CalendarHeaderRow,\n        headerCellComponent: CalendarHeaderCell,\n        navigatorComponent: CalendarNavigator,\n        onSelectedDateChange: calendarDateChanged,\n        formatDate: formatDate\n      })));\n    }), createElement(TemplatePlaceholder, null)));\n  };\n\n  DateNavigatorBase.components = {\n    rootComponent: 'Root',\n    overlayComponent: 'Overlay',\n    openButtonComponent: 'OpenButton',\n    navigationButtonComponent: 'NavigationButton',\n    calendarComponent: 'Calendar',\n    calendarRowComponent: 'CalendarRow',\n    calendarCellComponent: 'CalendarCell',\n    calendarHeaderRowComponent: 'CalendarHeaderRow',\n    calendarHeaderCellComponent: 'CalendarHeaderCell',\n    calendarTextComponent: 'CalendarText',\n    calendarNavigatorComponent: 'CalendarNavigator',\n    calendarNavigationButtonComponent: 'CalendarNavigationButton'\n  };\n  return DateNavigatorBase;\n}(PureComponent);\n/** A plugin that renders the Scheduler’s date navigator. */\n\n\nvar DateNavigator = DateNavigatorBase;\nvar pluginDependencies$1 = [{\n  name: 'Toolbar'\n}, {\n  name: 'ViewState'\n}];\n\nvar ViewSwitcherBase = /*#__PURE__*/function (_super) {\n  __extends(ViewSwitcherBase, _super);\n\n  function ViewSwitcherBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ViewSwitcherBase.prototype.render = function () {\n    var Switcher = this.props.switcherComponent;\n    return createElement(Plugin, {\n      name: \"ViewSwitcher\",\n      dependencies: pluginDependencies$1\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var currentView = _a.currentView,\n          availableViews = _a.availableViews;\n      var setCurrentViewName = _b.setCurrentViewName;\n      return createElement(Switcher, {\n        currentView: currentView,\n        availableViews: availableViews,\n        onChange: setCurrentViewName\n      });\n    })));\n  };\n\n  ViewSwitcherBase.components = {\n    switcherComponent: 'Switcher'\n  };\n  return ViewSwitcherBase;\n}(PureComponent);\n/** A plugin that renders the Scheduler's view switcher. */\n\n\nvar ViewSwitcher = ViewSwitcherBase;\n\nvar AppointmentPlaceholder = function AppointmentPlaceholder(params) {\n  return createElement(TemplatePlaceholder, {\n    name: \"appointment\",\n    params: params\n  });\n};\n\nvar renderAppointments = function renderAppointments(rects) {\n  return rects.map(function (_a, index) {\n    var dataItem = _a.dataItem,\n        rectType = _a.type,\n        fromPrev = _a.fromPrev,\n        toNext = _a.toNext,\n        durationType = _a.durationType,\n        resources = _a.resources,\n        geometry = __rest(_a, [\"dataItem\", \"type\", \"fromPrev\", \"toNext\", \"durationType\", \"resources\"]);\n\n    return createElement(AppointmentPlaceholder, {\n      key: index.toString(),\n      type: rectType,\n      data: dataItem,\n      fromPrev: fromPrev,\n      toNext: toNext,\n      durationType: durationType,\n      resources: resources,\n      style: getAppointmentStyle(geometry)\n    });\n  });\n};\n\nvar pluginDependencies$2 = [{\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}, {\n  name: 'MonthView',\n  optional: true\n}];\n\nvar AppointmentsBase = /*#__PURE__*/function (_super) {\n  __extends(AppointmentsBase, _super);\n\n  function AppointmentsBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.updateTimeTableAppointments = memoize(function (timeTableAppointments, viewCellsData, timeTableElementsMeta, currentView, startViewDate, endViewDate, cellDuration, groups, getGroupOrientation, groupByDate) {\n      if (!isTimeTableElementsMetaActual(viewCellsData, timeTableElementsMeta)) return null;\n      var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION;\n      var groupCount = groups ? groups[groups.length - 1].length : 1;\n      var appointmentType = {\n        growDirection: VERTICAL_TYPE,\n        multiline: false\n      };\n      var getRects = getVerticalRectByAppointmentData;\n\n      if (currentView.type === VIEW_TYPES.MONTH) {\n        appointmentType = {\n          growDirection: HORIZONTAL_TYPE,\n          multiline: true\n        };\n        getRects = getHorizontalRectByAppointmentData;\n      }\n\n      return renderAppointments(calculateRectByDateAndGroupIntervals(appointmentType, timeTableAppointments, getRects, {\n        startViewDate: startViewDate,\n        endViewDate: endViewDate,\n        cellDuration: cellDuration,\n        viewCellsData: viewCellsData,\n        cellElementsMeta: timeTableElementsMeta\n      }, {\n        groupOrientation: groupOrientation,\n        groupedByDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name),\n        groupCount: groupCount\n      }));\n    });\n    _this.updateAllDayAppointments = memoize(function (allDayAppointments, viewCellsData, allDayElementsMeta, currentView, startViewDate, endViewDate, groups, getGroupOrientation, groupByDate) {\n      var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION;\n      var groupCount = groups ? groups[groups.length - 1].length : 1;\n\n      if (!isAllDayElementsMetaActual(viewCellsData, allDayElementsMeta, groupOrientation, groupCount)) {\n        return null;\n      }\n\n      return renderAppointments(calculateRectByDateAndGroupIntervals({\n        growDirection: HORIZONTAL_TYPE,\n        multiline: false\n      }, allDayAppointments, getHorizontalRectByAppointmentData, {\n        startViewDate: startViewDate,\n        endViewDate: endViewDate,\n        viewCellsData: viewCellsData,\n        cellElementsMeta: allDayElementsMeta\n      }, {\n        groupOrientation: groupOrientation,\n        groupedByDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name),\n        groupCount: groupCount\n      }));\n    });\n    return _this;\n  }\n\n  AppointmentsBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        SplitIndicator = _a.splitIndicatorComponent,\n        Appointment = _a.appointmentComponent,\n        AppointmentContent = _a.appointmentContentComponent,\n        Container = _a.containerComponent,\n        recurringIconComponent = _a.recurringIconComponent;\n    return createElement(Plugin, {\n      name: \"Appointments\",\n      dependencies: pluginDependencies$2\n    }, createElement(Template, {\n      name: \"timeTableAppointmentLayer\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var timeTableAppointments = _a.timeTableAppointments,\n          viewCellsData = _a.viewCellsData,\n          timeTableElementsMeta = _a.timeTableElementsMeta,\n          currentView = _a.currentView,\n          startViewDate = _a.startViewDate,\n          endViewDate = _a.endViewDate,\n          cellDuration = _a.cellDuration,\n          groupOrientation = _a.groupOrientation,\n          groups = _a.groups,\n          groupByDate = _a.groupByDate;\n      return _this.updateTimeTableAppointments(timeTableAppointments, viewCellsData, timeTableElementsMeta, currentView, startViewDate, endViewDate, cellDuration, groups, groupOrientation, groupByDate);\n    })), createElement(Template, {\n      name: \"allDayAppointmentLayer\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var allDayAppointments = _a.allDayAppointments,\n          viewCellsData = _a.viewCellsData,\n          allDayElementsMeta = _a.allDayElementsMeta,\n          startViewDate = _a.startViewDate,\n          endViewDate = _a.endViewDate,\n          groupOrientation = _a.groupOrientation,\n          currentView = _a.currentView,\n          groups = _a.groups,\n          groupByDate = _a.groupByDate;\n      return _this.updateAllDayAppointments(allDayAppointments, viewCellsData, allDayElementsMeta, currentView, startViewDate, endViewDate, groups, groupOrientation, groupByDate);\n    })), createElement(Template, {\n      name: \"appointment\"\n    }, function (_a) {\n      var style = _a.style,\n          params = __rest(_a, [\"style\"]);\n\n      return createElement(TemplateConnector, null, function (_a) {\n        var formatDate = _a.formatDate;\n        return createElement(Container, {\n          style: style\n        }, createElement(TemplatePlaceholder, {\n          name: \"appointmentTop\",\n          params: {\n            data: params.data,\n            type: params.type,\n            slice: params.fromPrev\n          }\n        }), createElement(TemplatePlaceholder, {\n          name: \"appointmentContent\",\n          params: _assign(_assign({}, params), {\n            formatDate: formatDate\n          })\n        }), createElement(TemplatePlaceholder, {\n          name: \"appointmentBottom\",\n          params: {\n            data: params.data,\n            type: params.type,\n            slice: params.toNext\n          }\n        }));\n      });\n    }), createElement(Template, {\n      name: \"appointmentContent\"\n    }, function (_a) {\n      var onClick = _a.onClick,\n          onDoubleClick = _a.onDoubleClick,\n          formatDate = _a.formatDate,\n          data = _a.data,\n          type = _a.type,\n          fromPrev = _a.fromPrev,\n          toNext = _a.toNext,\n          durationType = _a.durationType,\n          resources = _a.resources,\n          restParams = __rest(_a, [\"onClick\", \"onDoubleClick\", \"formatDate\", \"data\", \"type\", \"fromPrev\", \"toNext\", \"durationType\", \"resources\"]);\n\n      return createElement(Appointment, _assign({\n        data: data,\n        resources: resources\n      }, createClickHandlers(onClick, onDoubleClick), restParams), fromPrev && createElement(SplitIndicator, {\n        position: POSITION_START,\n        appointmentType: type\n      }), createElement(AppointmentContent, {\n        data: data,\n        type: type,\n        durationType: durationType,\n        recurringIconComponent: recurringIconComponent,\n        formatDate: formatDate,\n        resources: resources\n      }), toNext && createElement(SplitIndicator, {\n        position: POSITION_END,\n        appointmentType: type\n      }));\n    }));\n  };\n\n  AppointmentsBase.components = {\n    splitIndicatorComponent: 'SplitIndicator',\n    containerComponent: 'Container',\n    appointmentComponent: 'Appointment',\n    appointmentContentComponent: 'AppointmentContent',\n    recurringIconComponent: 'RecurringIcon'\n  };\n  return AppointmentsBase;\n}(PureComponent);\n/** A plugin that renders appointments. */\n\n\nvar Appointments = AppointmentsBase;\nvar pluginDependencies$3 = [{\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}];\nvar defaultMessages = {\n  allDay: 'All Day'\n};\n\nvar AllDayAppointmentLayerPlaceholder = function AllDayAppointmentLayerPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"allDayAppointmentLayer\"\n  });\n};\n\nvar AllDayPanelPlaceholder = function AllDayPanelPlaceholder(params) {\n  return createElement(TemplatePlaceholder, {\n    name: \"allDayPanel\",\n    params: params\n  });\n};\n\nvar CellPlaceholder$1 = function CellPlaceholder$1(params) {\n  return createElement(TemplatePlaceholder, {\n    name: \"allDayPanelCell\",\n    params: params\n  });\n};\n\nvar GroupingPanelPlaceholder$1 = function GroupingPanelPlaceholder$1() {\n  return createElement(TemplatePlaceholder, {\n    name: \"allDayGroupingPanel\"\n  });\n};\n\nvar AllDayPanelBase = /*#__PURE__*/function (_super) {\n  __extends(AllDayPanelBase, _super);\n\n  function AllDayPanelBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      elementsMeta: {},\n      previousCell: null,\n      // The key has to be generated every time the Cell component is updated to rerender the Layout\n      // and, consequently, update allDayElementsMeta\n      layoutKey: 0\n    };\n    _this.allDayCellsData = memoize(function (viewCellsData) {\n      return allDayCells(viewCellsData);\n    });\n    _this.updateCellElementsMeta = memoize(function (cellElementsMeta) {\n      _this.setState({\n        elementsMeta: cellElementsMeta\n      });\n    });\n    _this.allDayAppointmentsComputed = memoize(function (_a) {\n      var appointments = _a.appointments,\n          startViewDate = _a.startViewDate,\n          endViewDate = _a.endViewDate,\n          excludedDays = _a.excludedDays;\n      var allDayLeftBound = moment(startViewDate).hours(0).minutes(0).toDate();\n      var allDayRightBound = moment(endViewDate).hours(23).minutes(59).toDate();\n      return calculateAllDayDateIntervals(appointments, allDayLeftBound, allDayRightBound, excludedDays);\n    });\n    _this.getMessageFormatter = memoize(function (messages, allDayPanelDefaultMessages) {\n      return getMessagesFormatter(_assign(_assign({}, allDayPanelDefaultMessages), messages));\n    });\n    return _this;\n  }\n\n  AllDayPanelBase.getDerivedStateFromProps = function (props, state) {\n    if (props.cellComponent !== state.previousCell) {\n      return _assign(_assign({}, state), {\n        previousCell: props.cellComponent,\n        layoutKey: Math.random()\n      });\n    }\n\n    return null;\n  };\n\n  AllDayPanelBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        AppointmentLayer = _a.appointmentLayerComponent,\n        Layout = _a.layoutComponent,\n        Cell = _a.cellComponent,\n        rowComponent = _a.rowComponent,\n        TitleCell = _a.titleCellComponent,\n        Container = _a.containerComponent,\n        messages = _a.messages;\n    var _b = this.state,\n        elementsMeta = _b.elementsMeta,\n        layoutKey = _b.layoutKey;\n    var getMessage = this.getMessageFormatter(messages, defaultMessages);\n    return createElement(Plugin, {\n      name: \"AllDayPanel\",\n      dependencies: pluginDependencies$3\n    }, createElement(Getter, {\n      name: \"allDayElementsMeta\",\n      value: elementsMeta\n    }), createElement(Getter, {\n      name: \"allDayAppointments\",\n      computed: this.allDayAppointmentsComputed\n    }), createElement(Template, {\n      name: \"body\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a) {\n        var groupOrientation = _a.groupOrientation,\n            currentView = _a.currentView;\n\n        if (currentView.type === VIEW_TYPES.MONTH) {\n          return createElement(TemplatePlaceholder, {\n            params: _assign({}, params)\n          });\n        }\n\n        return createElement(TemplatePlaceholder, {\n          params: _assign(_assign({}, params), {\n            highlightDayScale: (groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(currentView.name)) === VERTICAL_GROUP_ORIENTATION\n          })\n        });\n      });\n    }), createElement(Template, {\n      name: \"dayScaleEmptyCell\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView,\n          groupOrientation = _a.groupOrientation;\n      if (currentView.type === VIEW_TYPES.MONTH) return createElement(TemplatePlaceholder, null);\n\n      if ((groupOrientation === null || groupOrientation === void 0 ? void 0 : groupOrientation(currentView.name)) === VERTICAL_GROUP_ORIENTATION) {\n        return createElement(GroupingPanelPlaceholder$1, null);\n      }\n\n      return createElement(TitleCell, {\n        getMessage: getMessage\n      });\n    })), createElement(Template, {\n      name: \"dayScale\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView;\n      if (currentView.type === VIEW_TYPES.MONTH) return null;\n      return createElement(Container, null, createElement(AllDayPanelPlaceholder, null));\n    })), createElement(Template, {\n      name: \"allDayPanel\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a) {\n      var currentView = _a.currentView,\n          formatDate = _a.formatDate,\n          viewCellsData = _a.viewCellsData,\n          groups = _a.groups,\n          getGroupOrientation = _a.groupOrientation;\n      if (currentView.type === VIEW_TYPES.MONTH) return null;\n      var groupOrientation = (getGroupOrientation === null || getGroupOrientation === void 0 ? void 0 : getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name)) || HORIZONTAL_GROUP_ORIENTATION;\n      return createElement(Fragment, null, createElement(Layout, {\n        cellComponent: CellPlaceholder$1,\n        rowComponent: rowComponent,\n        cellsData: _this.allDayCellsData(viewCellsData),\n        setCellElementsMeta: _this.updateCellElementsMeta,\n        formatDate: formatDate,\n        groups: groupOrientation === VERTICAL_GROUP_ORIENTATION ? groups : undefined,\n        groupOrientation: groupOrientation,\n        key: layoutKey\n      }), createElement(AppointmentLayer, null, createElement(AllDayAppointmentLayerPlaceholder, null)));\n    })), createElement(Template, {\n      name: \"allDayPanelCell\"\n    }, function (params) {\n      return createElement(Cell, _assign({}, params));\n    }));\n  };\n\n  AllDayPanelBase.defaultProps = {\n    messages: {}\n  };\n  AllDayPanelBase.components = {\n    appointmentLayerComponent: 'AppointmentLayer',\n    layoutComponent: 'Layout',\n    layoutContainerComponent: 'LayoutContainer',\n    cellComponent: 'Cell',\n    rowComponent: 'Row',\n    titleCellComponent: 'TitleCell',\n    containerComponent: 'Container'\n  };\n  return AllDayPanelBase;\n}(PureComponent);\n/** A plugin that renders the All Day Panel. */\n\n\nvar AllDayPanel = AllDayPanelBase;\n\nvar ViewStateBase = /*#__PURE__*/function (_super) {\n  __extends(ViewStateBase, _super);\n\n  function ViewStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.getCurrentViewComputed = memoize(function (currentViewName) {\n      return function () {\n        return currentViewName ? {\n          name: currentViewName\n        } : undefined;\n      };\n    });\n    _this.state = {\n      currentDate: props.currentDate || props.defaultCurrentDate,\n      currentViewName: props.currentViewName || props.defaultCurrentViewName\n    };\n    var stateHelper = createStateHelper(_this, {\n      currentDate: function currentDate() {\n        var onCurrentDateChange = _this.props.onCurrentDateChange;\n        return onCurrentDateChange;\n      },\n      currentViewName: function currentViewName() {\n        var onCurrentViewNameChange = _this.props.onCurrentViewNameChange;\n        return onCurrentViewNameChange;\n      }\n    });\n    _this.changeCurrentDate = stateHelper.applyFieldReducer.bind(stateHelper, 'currentDate', changeCurrentDate);\n    _this.setCurrentViewName = stateHelper.applyFieldReducer.bind(stateHelper, 'currentViewName', setCurrentViewName);\n    return _this;\n  }\n\n  ViewStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.currentDate,\n        currentDate = _a === void 0 ? prevState.currentDate : _a,\n        _b = nextProps.currentViewName,\n        currentViewName = _b === void 0 ? prevState.currentViewName : _b;\n    return {\n      currentDate: currentDate,\n      currentViewName: currentViewName\n    };\n  };\n\n  ViewStateBase.prototype.render = function () {\n    var _a = this.state,\n        currentDate = _a.currentDate,\n        stateCurrentViewName = _a.currentViewName;\n    return createElement(Plugin, {\n      name: \"ViewState\"\n    }, createElement(Getter, {\n      name: \"currentDate\",\n      value: currentDate\n    }), createElement(Getter, {\n      name: \"currentView\",\n      computed: this.getCurrentViewComputed(stateCurrentViewName)\n    }), createElement(Action, {\n      name: \"changeCurrentDate\",\n      action: this.changeCurrentDate\n    }), createElement(Action, {\n      name: \"setCurrentViewName\",\n      action: this.setCurrentViewName\n    }));\n  };\n\n  ViewStateBase.defaultProps = {\n    defaultCurrentDate: new Date()\n  };\n  return ViewStateBase;\n}(PureComponent);\n/** A plugin that manages the view state. It specifies the current date and the displayed view. */\n\n\nvar ViewState = ViewStateBase;\n\nvar EditingStateBase = /*#__PURE__*/function (_super) {\n  __extends(EditingStateBase, _super);\n\n  function EditingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      editingAppointment: props.editingAppointment || props.defaultEditingAppointment,\n      addedAppointment: props.addedAppointment || props.defaultAddedAppointment,\n      appointmentChanges: props.appointmentChanges || props.defaultAppointmentChanges\n    };\n    var stateHelper = createStateHelper(_this, {\n      editingAppointment: function editingAppointment() {\n        var onEditingAppointmentChange = _this.props.onEditingAppointmentChange;\n        return onEditingAppointmentChange;\n      },\n      addedAppointment: function addedAppointment() {\n        var onAddedAppointmentChange = _this.props.onAddedAppointmentChange;\n        return onAddedAppointmentChange;\n      },\n      appointmentChanges: function appointmentChanges() {\n        var onAppointmentChangesChange = _this.props.onAppointmentChangesChange;\n        return onAppointmentChangesChange;\n      }\n    });\n    _this.startEditAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'editingAppointment', startEditAppointment);\n    _this.stopEditAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'editingAppointment', stopEditAppointment);\n    _this.changeAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'appointmentChanges', changeAppointment);\n    _this.cancelChangedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'appointmentChanges', cancelChanges);\n\n    _this.commitChangedAppointment = function (type) {\n      if (type === void 0) {\n        type = RECURRENCE_EDIT_SCOPE.CURRENT;\n      }\n\n      var _a = _this.state,\n          appointmentChanges = _a.appointmentChanges,\n          editingAppointment = _a.editingAppointment;\n      var _b = _this.props,\n          onCommitChanges = _b.onCommitChanges,\n          preCommitChanges = _b.preCommitChanges;\n      if (!editingAppointment) return;\n      var changes = !editingAppointment.rRule ? {\n        changed: changedAppointmentById(appointmentChanges, editingAppointment.id)\n      } : preCommitChanges(appointmentChanges, editingAppointment, type);\n      onCommitChanges(changes);\n\n      _this.cancelChangedAppointment();\n\n      _this.stopEditAppointment();\n    };\n\n    _this.addAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'addedAppointment', addAppointment);\n    _this.changeAddedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'addedAppointment', changeAppointment);\n    _this.cancelAddedAppointment = stateHelper.applyFieldReducer.bind(stateHelper, 'addedAppointment', cancelAddedAppointment);\n\n    _this.commitAddedAppointment = function () {\n      var onCommitChanges = _this.props.onCommitChanges;\n      var stateAddedAppointment = _this.state.addedAppointment;\n      onCommitChanges({\n        added: stateAddedAppointment\n      });\n    };\n\n    _this.commitDeletedAppointment = function (_a) {\n      var deletedAppointmentData = _a.deletedAppointmentData,\n          _b = _a.type,\n          type = _b === void 0 ? 'current' : _b;\n      var _c = _this.props,\n          onCommitChanges = _c.onCommitChanges,\n          preCommitChanges = _c.preCommitChanges;\n      var changes = deletedAppointmentData.rRule ? preCommitChanges(null, deletedAppointmentData, type) : {\n        deleted: deletedAppointmentData.id\n      };\n      onCommitChanges(changes);\n    };\n\n    return _this;\n  }\n\n  EditingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.editingAppointment,\n        editingAppointment = _a === void 0 ? prevState.editingAppointment : _a,\n        _b = nextProps.appointmentChanges,\n        appointmentChanges = _b === void 0 ? prevState.appointmentChanges : _b,\n        _c = nextProps.addedAppointment,\n        addedAppointment = _c === void 0 ? prevState.addedAppointment : _c;\n    return {\n      editingAppointment: editingAppointment,\n      appointmentChanges: appointmentChanges,\n      addedAppointment: addedAppointment\n    };\n  };\n\n  EditingStateBase.prototype.render = function () {\n    var _a = this.state,\n        addedAppointment = _a.addedAppointment,\n        editingAppointment = _a.editingAppointment,\n        appointmentChanges = _a.appointmentChanges;\n    return createElement(Plugin, {\n      name: \"EditingState\"\n    }, createElement(Getter, {\n      name: \"editingAppointment\",\n      value: editingAppointment\n    }), createElement(Action, {\n      name: \"startEditAppointment\",\n      action: this.startEditAppointment\n    }), createElement(Action, {\n      name: \"stopEditAppointment\",\n      action: this.stopEditAppointment\n    }), createElement(Getter, {\n      name: \"appointmentChanges\",\n      value: appointmentChanges\n    }), createElement(Action, {\n      name: \"changeAppointment\",\n      action: this.changeAppointment\n    }), createElement(Action, {\n      name: \"cancelChangedAppointment\",\n      action: this.cancelChangedAppointment\n    }), createElement(Action, {\n      name: \"commitChangedAppointment\",\n      action: this.commitChangedAppointment\n    }), createElement(Getter, {\n      name: \"addedAppointment\",\n      value: addedAppointment\n    }), createElement(Action, {\n      name: \"addAppointment\",\n      action: this.addAppointment\n    }), createElement(Action, {\n      name: \"changeAddedAppointment\",\n      action: this.changeAddedAppointment\n    }), createElement(Action, {\n      name: \"cancelAddedAppointment\",\n      action: this.cancelAddedAppointment\n    }), createElement(Action, {\n      name: \"commitAddedAppointment\",\n      action: this.commitAddedAppointment\n    }), createElement(Action, {\n      name: \"commitDeletedAppointment\",\n      action: this.commitDeletedAppointment\n    }));\n  };\n\n  EditingStateBase.defaultProps = {\n    defaultEditingAppointment: undefined,\n    defaultAppointmentChanges: {},\n    defaultAddedAppointment: {},\n    preCommitChanges: preCommitChanges\n  };\n  return EditingStateBase;\n}(PureComponent);\n/** A plugin that manages the scheduler appointment editing state. */\n\n\nvar EditingState = EditingStateBase;\nvar pluginDependencies$4 = [{\n  name: 'Appointments'\n}, {\n  name: 'EditingState',\n  optional: true\n}, {\n  name: 'EditRecurrenceMenu',\n  optional: true\n}, {\n  name: 'IntegratedEditing',\n  optional: true\n}];\nvar commandButtonIds = {\n  open: OPEN_COMMAND_BUTTON,\n  close: CLOSE_COMMAND_BUTTON,\n  delete: DELETE_COMMAND_BUTTON\n};\n\nvar AppointmentTooltipBase = /*#__PURE__*/function (_super) {\n  __extends(AppointmentTooltipBase, _super);\n\n  function AppointmentTooltipBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      visible: props.visible,\n      appointmentMeta: props.appointmentMeta\n    };\n    var stateHelper = createStateHelper(_this, {\n      visible: function visible() {\n        var onVisibilityChange = _this.props.onVisibilityChange;\n        return onVisibilityChange;\n      },\n      appointmentMeta: function appointmentMeta() {\n        var onAppointmentMetaChange = _this.props.onAppointmentMetaChange;\n        return onAppointmentMetaChange;\n      }\n    });\n\n    var toggleVisibility = function toggleVisibility() {\n      var isOpen = _this.state.visible;\n      return !isOpen;\n    };\n\n    _this.toggleVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'visible', toggleVisibility);\n    _this.setAppointmentMeta = stateHelper.applyFieldReducer.bind(stateHelper, 'appointmentMeta', setAppointmentMeta);\n\n    _this.onAppointmentClick = function (_a) {\n      var target = _a.target,\n          data = _a.data;\n\n      _this.setAppointmentMeta({\n        target: target,\n        data: data\n      });\n\n      _this.toggleVisibility();\n    };\n\n    return _this;\n  }\n\n  AppointmentTooltipBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.visible,\n        visible = _a === void 0 ? prevState.visible : _a,\n        _b = nextProps.appointmentMeta,\n        appointmentMeta = _b === void 0 ? prevState.appointmentMeta : _b;\n    return {\n      appointmentMeta: appointmentMeta,\n      visible: visible\n    };\n  };\n\n  AppointmentTooltipBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        showOpenButton = _a.showOpenButton,\n        showDeleteButton = _a.showDeleteButton,\n        showCloseButton = _a.showCloseButton,\n        Layout = _a.layoutComponent,\n        headerComponent = _a.headerComponent,\n        contentComponent = _a.contentComponent,\n        commandButtonComponent = _a.commandButtonComponent,\n        recurringIconComponent = _a.recurringIconComponent;\n    var _b = this.state,\n        visible = _b.visible,\n        appointmentMeta = _b.appointmentMeta;\n    return createElement(Plugin, {\n      name: \"AppointmentTooltip\",\n      dependencies: pluginDependencies$4\n    }, createElement(Action, {\n      name: TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY,\n      action: this.toggleVisibility\n    }), createElement(Template, {\n      name: \"timeTable\"\n    }, createElement(TemplatePlaceholder, null), createElement(TemplateConnector, null, function (_a, _b) {\n      var formatDate = _a.formatDate,\n          resources = _a.resources,\n          plainResources = _a.plainResources;\n      var finishDeleteAppointment = _b.finishDeleteAppointment,\n          openDeleteConfirmationDialog = _b.openDeleteConfirmationDialog;\n\n      var onDeleteButtonClick = function onDeleteButtonClick() {\n        if (openDeleteConfirmationDialog) {\n          openDeleteConfirmationDialog({\n            hideActionName: TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY,\n            appointmentData: appointmentMeta.data\n          });\n        } else {\n          _this.toggleVisibility();\n\n          finishDeleteAppointment(appointmentMeta.data);\n        }\n      };\n\n      return createElement(TemplatePlaceholder, {\n        name: \"tooltip\",\n        params: _assign(_assign({\n          commandButtonComponent: commandButtonComponent,\n          recurringIconComponent: recurringIconComponent,\n          showOpenButton: showOpenButton,\n          showDeleteButton: showDeleteButton,\n          showCloseButton: showCloseButton,\n          headerComponent: headerComponent,\n          contentComponent: contentComponent,\n          appointmentMeta: appointmentMeta,\n          appointmentResources: appointmentMeta ? getAppointmentResources(appointmentMeta.data, resources, plainResources) : [],\n          visible: visible,\n          onHide: _this.toggleVisibility,\n          commandButtonIds: commandButtonIds\n        }, finishDeleteAppointment && {\n          onDeleteButtonClick: onDeleteButtonClick\n        }), {\n          formatDate: formatDate\n        })\n      });\n    })), createElement(Template, {\n      name: \"tooltip\"\n    }, function (params) {\n      return createElement(Layout, _assign({}, params));\n    }), createElement(Template, {\n      name: \"appointment\"\n    }, function (params) {\n      return createElement(TemplatePlaceholder, {\n        params: _assign(_assign({}, params), {\n          onClick: function onClick(_a) {\n            var target = _a.target,\n                data = _a.data;\n            return _this.onAppointmentClick({\n              target: target,\n              data: data\n            });\n          }\n        })\n      });\n    }));\n  };\n\n  AppointmentTooltipBase.defaultProps = {\n    showOpenButton: false,\n    showDeleteButton: false,\n    showCloseButton: false\n  };\n  AppointmentTooltipBase.components = {\n    layoutComponent: 'Layout',\n    headerComponent: 'Header',\n    contentComponent: 'Content',\n    commandButtonComponent: 'CommandButton',\n    recurringIconComponent: 'RecurringIcon'\n  };\n  return AppointmentTooltipBase;\n}(PureComponent); // tslint:disable: max-line-length\n\n/** The AppointmentTooltip plugin allows you to display information about an appointment in a tooltip. */\n\n\nvar AppointmentTooltip = AppointmentTooltipBase;\n\nvar addDoubleClickToCell = function addDoubleClickToCell(title, startDate, endDate, groupingInfo, resources, allDay, openFormHandler, addAppointment, params) {\n  var resourceFields = !!groupingInfo ? groupingInfo.reduce(function (acc, currentGroup) {\n    var _a;\n\n    return _assign(_assign({}, acc), (_a = {}, _a[currentGroup.fieldName] = currentGroup.id, _a));\n  }, {}) : {};\n  var validResourceFields = resources ? checkMultipleResourceFields(resourceFields, resources) : resourceFields;\n\n  var newAppointmentData = _assign({\n    title: title,\n    startDate: startDate,\n    endDate: endDate,\n    allDay: allDay\n  }, validResourceFields);\n\n  return createElement(TemplatePlaceholder, {\n    params: _assign(_assign({}, params), {\n      onDoubleClick: function onDoubleClick() {\n        openFormHandler(newAppointmentData);\n        callActionIfExists(addAppointment, {\n          appointmentData: newAppointmentData\n        });\n      }\n    })\n  });\n};\n\nvar defaultMessages$1 = {\n  allDayLabel: 'All Day',\n  titleLabel: 'Title',\n  commitCommand: 'Save',\n  detailsLabel: 'Details',\n  moreInformationLabel: 'More Information',\n  repeatLabel: 'Repeat',\n  notesLabel: 'Notes',\n  never: 'Never',\n  daily: 'Daily',\n  weekly: 'Weekly',\n  monthly: 'Monthly',\n  yearly: 'Yearly',\n  repeatEveryLabel: 'Repeat every',\n  daysLabel: 'day(s)',\n  endRepeatLabel: 'End repeat',\n  onLabel: 'On',\n  afterLabel: 'After',\n  occurrencesLabel: 'occurrence(s)',\n  weeksOnLabel: 'week(s) on:',\n  monthsLabel: 'month(s)',\n  ofEveryMonthLabel: 'of every month',\n  theLabel: 'The',\n  firstLabel: 'First',\n  secondLabel: 'Second',\n  thirdLabel: 'Third',\n  fourthLabel: 'Fourth',\n  lastLabel: 'Last',\n  yearsLabel: 'year(s)',\n  ofLabel: 'of ',\n  everyLabel: 'Every'\n};\n\nvar CommandLayoutPlaceholder = function CommandLayoutPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"commandLayout\"\n  });\n};\n\nvar BasicLayoutPlaceholder = function BasicLayoutPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"basicLayout\"\n  });\n};\n\nvar RecurrenceLayoutPlaceholder = function RecurrenceLayoutPlaceholder() {\n  return createElement(TemplatePlaceholder, {\n    name: \"recurrenceLayout\"\n  });\n};\n\nvar pluginDependencies$5 = [{\n  name: 'EditingState',\n  optional: true\n}, {\n  name: 'Appointments',\n  optional: true\n}, {\n  name: 'AppointmentTooltip',\n  optional: true\n}, {\n  name: 'EditRecurrenceMenu',\n  optional: true\n}, {\n  name: 'IntegratedEditing',\n  optional: true\n}];\n\nvar prepareChanges = function prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources) {\n  var isNew = !editingAppointment;\n\n  var changedAppointment = _assign(_assign(_assign({}, appointmentData), appointmentChanges), isNew && addedAppointment);\n\n  var appointmentResources = getAppointmentResources(changedAppointment, resources, plainResources);\n  var isFormEdited = isNew || Object.getOwnPropertyNames(appointmentChanges).length !== 0;\n  return {\n    changedAppointment: changedAppointment,\n    appointmentResources: appointmentResources,\n    isNew: isNew,\n    isFormEdited: isFormEdited\n  };\n};\n\nvar isFormFullSize = function isFormFullSize(isFormVisible, changedAppointmentRRule, previousAppointmentRRule) {\n  return !!changedAppointmentRRule || !isFormVisible && !!previousAppointmentRRule;\n};\n\nvar AppointmentFormBase = /*#__PURE__*/function (_super) {\n  __extends(AppointmentFormBase, _super);\n\n  function AppointmentFormBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.container = createRef();\n    _this.commitChanges = memoize(function (finishCommitAppointment, commitAddedAppointment, isNew, changedAppointment) {\n      return function () {\n        _this.toggleVisibility();\n\n        if (isNew) {\n          callActionIfExists(commitAddedAppointment, changedAppointment);\n        } else if (finishCommitAppointment) {\n          finishCommitAppointment();\n        }\n\n        _this.setState({\n          previousAppointment: changedAppointment\n        });\n      };\n    });\n    _this.cancelChanges = memoize(function (openCancelConfirmationDialog, isNew, stopEditAppointment, appointmentChanges, changedAppointment, cancelAddedAppointment, cancelChangedAppointment) {\n      return function () {\n        if (openCancelConfirmationDialog && Object.keys(appointmentChanges).length !== 0) {\n          openCancelConfirmationDialog(TOGGLE_APPOINTMENT_FORM_VISIBILITY);\n        } else {\n          if (isNew) {\n            callActionIfExists(cancelAddedAppointment, appointmentChanges);\n          } else {\n            callActionIfExists(stopEditAppointment, appointmentChanges);\n            callActionIfExists(cancelChangedAppointment, appointmentChanges);\n          }\n\n          _this.toggleVisibility();\n        }\n\n        _this.setState({\n          previousAppointment: changedAppointment\n        });\n      };\n    });\n    _this.deleteAppointment = memoize(function (finishDeleteAppointment, appointmentData, openDeleteConfirmationDialog, changedAppointment, cancelAddedAppointment, cancelChangedAppointment, stopEditAppointment, isNew) {\n      return function () {\n        if (openDeleteConfirmationDialog) {\n          openDeleteConfirmationDialog({\n            hideActionName: TOGGLE_APPOINTMENT_FORM_VISIBILITY,\n            appointmentData: changedAppointment\n          });\n        } else {\n          callActionIfExists(finishDeleteAppointment, appointmentData);\n\n          if (isNew) {\n            callActionIfExists(cancelAddedAppointment, appointmentData);\n          } else {\n            callActionIfExists(cancelChangedAppointment, appointmentData);\n            callActionIfExists(stopEditAppointment, appointmentData);\n          }\n\n          _this.toggleVisibility();\n        }\n\n        _this.setState({\n          previousAppointment: changedAppointment\n        });\n      };\n    });\n    _this.changeAppointmentField = memoize(function (isNew, changeAddedAppointment, changeAppointment) {\n      return function (change) {\n        if (change && change.rRule) {\n          _this.setState({\n            previousAppointment: _assign(_assign({}, _this.state.previousAppointment), {\n              rRule: change.rRule\n            })\n          });\n        }\n\n        if (isNew) {\n          callActionIfExists(changeAddedAppointment, {\n            change: change\n          });\n        } else {\n          callActionIfExists(changeAppointment, {\n            change: change\n          });\n        }\n      };\n    });\n    _this.getMessage = memoize(function (menuMessages, messages) {\n      return getMessagesFormatter(_assign(_assign({}, menuMessages), messages));\n    });\n    _this.state = {\n      visible: props.visible,\n      appointmentData: props.appointmentData || {},\n      previousAppointment: props.appointmentData || {}\n    };\n    var stateHelper = createStateHelper(_this, {\n      visible: function visible() {\n        var onVisibilityChange = _this.props.onVisibilityChange;\n        return onVisibilityChange;\n      },\n      appointmentData: function appointmentData() {\n        var onAppointmentDataChange = _this.props.onAppointmentDataChange;\n        return onAppointmentDataChange;\n      }\n    });\n\n    var toggleVisibility = function toggleVisibility() {\n      var isOpen = _this.state.visible;\n      return !isOpen;\n    };\n\n    _this.toggleVisibility = stateHelper.applyFieldReducer.bind(stateHelper, 'visible', toggleVisibility);\n    _this.setAppointmentData = stateHelper.applyFieldReducer.bind(stateHelper, 'appointmentData', setAppointmentData);\n\n    _this.openFormHandler = function (appointmentData) {\n      _this.setAppointmentData({\n        appointmentData: appointmentData\n      });\n\n      _this.toggleVisibility();\n    };\n\n    return _this;\n  }\n\n  AppointmentFormBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.visible,\n        visible = _a === void 0 ? prevState.visible : _a,\n        _b = nextProps.appointmentData,\n        appointmentData = _b === void 0 ? prevState.appointmentData : _b;\n    return {\n      appointmentData: appointmentData,\n      visible: visible\n    };\n  };\n\n  AppointmentFormBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        Container = _a.containerComponent,\n        Overlay = _a.overlayComponent,\n        Layout = _a.layoutComponent,\n        CommandLayout = _a.commandLayoutComponent,\n        BasicLayout = _a.basicLayoutComponent,\n        RecurrenceLayout = _a.recurrenceLayoutComponent,\n        commandButtonComponent = _a.commandButtonComponent,\n        textEditorComponent = _a.textEditorComponent,\n        labelComponent = _a.labelComponent,\n        dateEditorComponent = _a.dateEditorComponent,\n        booleanEditorComponent = _a.booleanEditorComponent,\n        selectComponent = _a.selectComponent,\n        radioGroupComponent = _a.radioGroupComponent,\n        weeklyRecurrenceSelectorComponent = _a.weeklyRecurrenceSelectorComponent,\n        resourceEditorComponent = _a.resourceEditorComponent,\n        readOnly = _a.readOnly,\n        messages = _a.messages;\n    var _b = this.state,\n        visible = _b.visible,\n        appointmentData = _b.appointmentData,\n        previousAppointment = _b.previousAppointment;\n    var getMessage = this.getMessage(defaultMessages$1, messages);\n    return createElement(Plugin, {\n      name: \"AppointmentForm\",\n      dependencies: pluginDependencies$5\n    }, createElement(Action, {\n      name: TOGGLE_APPOINTMENT_FORM_VISIBILITY,\n      action: this.toggleVisibility\n    }), createElement(Template, {\n      name: \"schedulerRoot\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var editingAppointment = _a.editingAppointment,\n          addedAppointment = _a.addedAppointment,\n          appointmentChanges = _a.appointmentChanges,\n          resources = _a.resources,\n          plainResources = _a.plainResources;\n      var openCancelConfirmationDialog = _b.openCancelConfirmationDialog,\n          stopEditAppointment = _b.stopEditAppointment,\n          cancelAddedAppointment = _b.cancelAddedAppointment,\n          cancelChangedAppointment = _b.cancelChangedAppointment;\n\n      var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources),\n          changedAppointment = _c.changedAppointment,\n          isNew = _c.isNew;\n\n      var fullSize = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);\n\n      var onHideAction = function onHideAction() {\n        return visible && _this.cancelChanges(openCancelConfirmationDialog, isNew, stopEditAppointment, _assign(_assign({}, appointmentChanges), addedAppointment), changedAppointment, cancelAddedAppointment, cancelChangedAppointment)();\n      };\n\n      return createElement(Fragment, null, createElement(Container, {\n        ref: _this.container\n      }), createElement(Overlay, {\n        visible: visible,\n        onHide: onHideAction,\n        fullSize: fullSize,\n        target: _this.container\n      }, createElement(Layout, {\n        basicLayoutComponent: BasicLayoutPlaceholder,\n        commandLayoutComponent: CommandLayoutPlaceholder,\n        recurrenceLayoutComponent: RecurrenceLayoutPlaceholder,\n        isRecurrence: fullSize\n      })), createElement(TemplatePlaceholder, null));\n    })), createElement(Template, {\n      name: \"commandLayout\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var editingAppointment = _a.editingAppointment,\n          addedAppointment = _a.addedAppointment,\n          appointmentChanges = _a.appointmentChanges,\n          resources = _a.resources,\n          plainResources = _a.plainResources;\n      var commitAddedAppointment = _b.commitAddedAppointment,\n          finishCommitAppointment = _b.finishCommitAppointment,\n          finishDeleteAppointment = _b.finishDeleteAppointment,\n          stopEditAppointment = _b.stopEditAppointment,\n          cancelAddedAppointment = _b.cancelAddedAppointment,\n          cancelChangedAppointment = _b.cancelChangedAppointment,\n          openCancelConfirmationDialog = _b.openCancelConfirmationDialog,\n          openDeleteConfirmationDialog = _b.openDeleteConfirmationDialog;\n\n      var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources),\n          isNew = _c.isNew,\n          changedAppointment = _c.changedAppointment,\n          isFormEdited = _c.isFormEdited;\n\n      var isRecurrence = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);\n      return createElement(CommandLayout, {\n        commandButtonComponent: commandButtonComponent,\n        onCommitButtonClick: _this.commitChanges(finishCommitAppointment, commitAddedAppointment, isNew, changedAppointment),\n        onCancelButtonClick: _this.cancelChanges(openCancelConfirmationDialog, isNew, stopEditAppointment, _assign(_assign({}, appointmentChanges), addedAppointment), changedAppointment, cancelAddedAppointment, cancelChangedAppointment),\n        onDeleteButtonClick: _this.deleteAppointment(finishDeleteAppointment, appointmentData, openDeleteConfirmationDialog, changedAppointment, cancelAddedAppointment, cancelChangedAppointment, stopEditAppointment, isNew),\n        getMessage: getMessage,\n        readOnly: readOnly,\n        fullSize: isRecurrence,\n        disableSaveButton: !isFormEdited,\n        hideDeleteButton: isNew\n      });\n    })), createElement(Template, {\n      name: \"basicLayout\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var editingAppointment = _a.editingAppointment,\n          addedAppointment = _a.addedAppointment,\n          appointmentChanges = _a.appointmentChanges,\n          locale = _a.locale,\n          resources = _a.resources,\n          plainResources = _a.plainResources;\n      var changeAppointment = _b.changeAppointment,\n          changeAddedAppointment = _b.changeAddedAppointment;\n\n      var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, resources, plainResources),\n          isNew = _c.isNew,\n          changedAppointment = _c.changedAppointment,\n          appointmentResources = _c.appointmentResources;\n\n      return createElement(BasicLayout, {\n        locale: locale,\n        appointmentData: visible ? changedAppointment : previousAppointment,\n        onFieldChange: _this.changeAppointmentField(isNew, changeAddedAppointment, changeAppointment),\n        getMessage: getMessage,\n        readOnly: readOnly,\n        textEditorComponent: textEditorComponent,\n        dateEditorComponent: dateEditorComponent,\n        booleanEditorComponent: booleanEditorComponent,\n        selectComponent: selectComponent,\n        labelComponent: labelComponent,\n        resourceEditorComponent: resourceEditorComponent,\n        fullSize: !changedAppointment.rRule,\n        resources: resources,\n        appointmentResources: appointmentResources\n      });\n    })), createElement(Template, {\n      name: \"recurrenceLayout\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var editingAppointment = _a.editingAppointment,\n          addedAppointment = _a.addedAppointment,\n          appointmentChanges = _a.appointmentChanges,\n          formatDate = _a.formatDate,\n          locale = _a.locale,\n          firstDayOfWeek = _a.firstDayOfWeek;\n      var changeAddedAppointment = _b.changeAddedAppointment,\n          changeAppointment = _b.changeAppointment;\n\n      var _c = prepareChanges(appointmentData, editingAppointment, addedAppointment, appointmentChanges, undefined, undefined),\n          isNew = _c.isNew,\n          changedAppointment = _c.changedAppointment;\n\n      var isRecurrenceLayoutVisible = isFormFullSize(visible, changedAppointment.rRule, previousAppointment.rRule);\n      var correctedAppointment = !changedAppointment.rRule ? _assign(_assign({}, changedAppointment), {\n        rRule: previousAppointment.rRule\n      }) : changedAppointment;\n      return createElement(RecurrenceLayout, {\n        locale: locale,\n        appointmentData: visible ? correctedAppointment : previousAppointment,\n        onFieldChange: _this.changeAppointmentField(isNew, changeAddedAppointment, changeAppointment),\n        getMessage: getMessage,\n        readOnly: readOnly,\n        formatDate: formatDate,\n        textEditorComponent: textEditorComponent,\n        dateEditorComponent: dateEditorComponent,\n        radioGroupComponent: radioGroupComponent,\n        weeklyRecurrenceSelectorComponent: weeklyRecurrenceSelectorComponent,\n        labelComponent: labelComponent,\n        selectComponent: selectComponent,\n        visible: isRecurrenceLayoutVisible,\n        firstDayOfWeek: firstDayOfWeek\n      });\n    })), createElement(Template, {\n      name: \"tooltip\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (getters, _a) {\n        var startEditAppointment = _a.startEditAppointment;\n        return createElement(TemplatePlaceholder, {\n          params: _assign(_assign({}, params), {\n            onOpenButtonClick: function onOpenButtonClick() {\n              _this.openFormHandler(params.appointmentMeta.data);\n\n              callActionIfExists(startEditAppointment, params.appointmentMeta.data);\n            }\n          })\n        });\n      });\n    }), createElement(Template, {\n      name: \"appointment\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (getters, _a) {\n        var startEditAppointment = _a.startEditAppointment;\n        return createElement(TemplatePlaceholder, {\n          params: _assign(_assign({}, params), {\n            onDoubleClick: function onDoubleClick() {\n              _this.openFormHandler(params.data);\n\n              callActionIfExists(startEditAppointment, params.data);\n            }\n          })\n        });\n      });\n    }), createElement(Template, {\n      name: \"cell\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var resources = _a.resources;\n        var addAppointment = _b.addAppointment;\n        return addDoubleClickToCell(undefined, params.startDate, params.endDate, params.groupingInfo, resources, isAllDayCell(params.startDate, params.endDate), _this.openFormHandler, addAppointment, params);\n      });\n    }), createElement(Template, {\n      name: \"allDayPanelCell\"\n    }, function (params) {\n      return createElement(TemplateConnector, null, function (_a, _b) {\n        var resources = _a.resources;\n        var addAppointment = _b.addAppointment;\n        return addDoubleClickToCell(undefined, params.startDate, params.endDate, params.groupingInfo, resources, true, _this.openFormHandler, addAppointment, params);\n      });\n    }));\n  };\n\n  AppointmentFormBase.defaultProps = {\n    messages: {},\n    readOnly: false,\n    onVisibilityChange: function onVisibilityChange() {\n      return undefined;\n    },\n    onAppointmentDataChange: function onAppointmentDataChange() {\n      return undefined;\n    }\n  };\n  AppointmentFormBase.components = {\n    overlayComponent: 'Overlay',\n    layoutComponent: 'Layout',\n    commandLayoutComponent: 'CommandLayout',\n    commandButtonComponent: 'CommandButton',\n    basicLayoutComponent: 'BasicLayout',\n    textEditorComponent: 'TextEditor',\n    labelComponent: 'Label',\n    dateEditorComponent: 'DateEditor',\n    booleanEditorComponent: 'BooleanEditor',\n    selectComponent: 'Select',\n    recurrenceLayoutComponent: 'RecurrenceLayout',\n    radioGroupComponent: 'RadioGroup',\n    weeklyRecurrenceSelectorComponent: 'WeeklyRecurrenceSelector',\n    resourceEditorComponent: 'ResourceEditor',\n    containerComponent: 'Container'\n  };\n  return AppointmentFormBase;\n}(PureComponent); // tslint:disable-next-line: max-line-length\n\n/** The AppointmentForm plugin renders a form that visualizes appointment’s data and allows a user to modify this data. */\n\n\nvar AppointmentForm = AppointmentFormBase;\n\nvar renderAppointmentItems = function renderAppointmentItems(items, Wrapper, draftData) {\n  return items.length > 0 ? createElement(Wrapper, null, items.map(function (draftAppointment, index) {\n    return createElement(TemplatePlaceholder, {\n      name: \"draftAppointment\",\n      key: index.toString(),\n      params: {\n        data: draftData,\n        draftAppointment: draftAppointment\n      }\n    });\n  })) : null;\n};\n\nvar pluginDependencies$6 = [{\n  name: 'EditingState'\n}, {\n  name: 'Appointments'\n}, {\n  name: 'EditRecurrenceMenu',\n  optional: true\n}, {\n  name: 'IntegratedEditing',\n  optional: true\n}, {\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}, {\n  name: 'MonthView',\n  optional: true\n}, {\n  name: 'AllDayPanel',\n  optional: true\n}];\n\nvar DragDropProviderBase = /*#__PURE__*/function (_super) {\n  __extends(DragDropProviderBase, _super);\n\n  function DragDropProviderBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.timeTableDraftAppointments = [];\n    _this.allDayDraftAppointments = [];\n    _this.offsetTimeTop = null;\n    _this.appointmentStartTime = null;\n    _this.appointmentEndTime = null;\n    _this.appointmentGroupingInfo = {};\n    _this.state = {\n      startTime: null,\n      endTime: null,\n      appointmentGroupingInfo: null,\n      payload: null,\n      isOutside: false,\n      allowDrag: function allowDrag() {\n        return true;\n      },\n      allowResize: function allowResize() {\n        return true;\n      },\n      appointmentContentTemplateKey: 0,\n      appointmentTopTemplateKey: 0,\n      appointmentBottomTemplateKey: 0\n    };\n\n    _this.handleDrop = function (_a) {\n      var finishCommitAppointment = _a.finishCommitAppointment;\n      return function () {\n        finishCommitAppointment();\n\n        _this.resetCache();\n      };\n    };\n\n    _this.handleLeave = function () {\n      _this.setState({\n        isOutside: true\n      });\n    };\n\n    return _this;\n  }\n\n  DragDropProviderBase.getDerivedStateFromProps = function (props, state) {\n    var isAllowDragSame = props.allowDrag === state.allowDrag;\n    var isAllowResizeSame = props.allowResize === state.allowResize;\n\n    if (isAllowDragSame && isAllowResizeSame) {\n      return null;\n    }\n\n    return _assign(_assign({}, state), {\n      appointmentContentTemplateKey: isAllowDragSame ? state.appointmentContentTemplateKey : Math.random(),\n      appointmentTopTemplateKey: isAllowResizeSame ? state.appointmentTopTemplateKey : Math.random(),\n      appointmentBottomTemplateKey: isAllowResizeSame ? state.appointmentBottomTemplateKey : Math.random(),\n      allowDrag: props.allowDrag,\n      allowResize: props.allowResize\n    });\n  };\n\n  DragDropProviderBase.prototype.onPayloadChange = function (actions) {\n    var _this = this;\n\n    return function (args) {\n      return _this.handlePayloadChange(args, actions);\n    };\n  };\n\n  DragDropProviderBase.prototype.calculateNextBoundaries = function (getters, actions) {\n    var _this = this;\n\n    return function (args) {\n      return _this.calculateBoundaries(args, getters, actions);\n    };\n  };\n\n  DragDropProviderBase.prototype.resetCache = function () {\n    this.timeTableDraftAppointments = [];\n    this.allDayDraftAppointments = [];\n    this.offsetTimeTop = null;\n    this.appointmentStartTime = null;\n    this.appointmentEndTime = null;\n    this.appointmentGroupingInfo = {};\n    this.setState({\n      payload: null,\n      startTime: null,\n      endTime: null,\n      isOutside: false\n    });\n  };\n\n  DragDropProviderBase.prototype.applyChanges = function (startTime, endTime, payload, startEditAppointment, changeAppointment, appointmentGroupingInfo) {\n    startEditAppointment(payload);\n    changeAppointment({\n      change: _assign(_assign({\n        startDate: startTime,\n        endDate: endTime\n      }, payload.allDay && {\n        allDay: undefined\n      }), this.appointmentGroupingInfo)\n    });\n    this.setState({\n      startTime: startTime,\n      endTime: endTime,\n      payload: payload,\n      isOutside: false,\n      appointmentGroupingInfo: appointmentGroupingInfo\n    });\n  };\n\n  DragDropProviderBase.prototype.handlePayloadChange = function (_a, _b) {\n    var payload = _a.payload;\n    var finishCommitAppointment = _b.finishCommitAppointment;\n    var isOutside = this.state.isOutside;\n    if (payload || !isOutside) return;\n    finishCommitAppointment();\n    this.resetCache();\n  };\n\n  DragDropProviderBase.prototype.calculateBoundaries = function (_a, _b, _c) {\n    var payload = _a.payload,\n        clientOffset = _a.clientOffset;\n    var viewCellsData = _b.viewCellsData,\n        startViewDate = _b.startViewDate,\n        endViewDate = _b.endViewDate,\n        excludedDays = _b.excludedDays,\n        currentView = _b.currentView,\n        timeTableElementsMeta = _b.timeTableElementsMeta,\n        allDayElementsMeta = _b.allDayElementsMeta,\n        scrollingStrategy = _b.scrollingStrategy,\n        grouping = _b.grouping,\n        resources = _b.resources,\n        groups = _b.groups,\n        getGroupOrientation = _b.groupOrientation,\n        groupByDate = _b.groupByDate;\n    var changeAppointment = _c.changeAppointment,\n        startEditAppointment = _c.startEditAppointment;\n\n    if (clientOffset) {\n      autoScroll(clientOffset, scrollingStrategy);\n    }\n\n    var tableCellElementsMeta = timeTableElementsMeta;\n    var groupOrientation = getGroupOrientation ? getGroupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) : HORIZONTAL_GROUP_ORIENTATION; // AllDayPanel doesn't always exist\n\n    var allDayCellsElementsMeta = allDayElementsMeta && allDayElementsMeta.getCellRects ? allDayElementsMeta : {\n      getCellRects: []\n    };\n    var timeTableIndex = cellIndex(tableCellElementsMeta.getCellRects, clientOffset);\n    var allDayIndex = cellIndex(allDayCellsElementsMeta.getCellRects, clientOffset);\n    if (allDayIndex === -1 && timeTableIndex === -1) return;\n    var targetData = cellData(timeTableIndex, allDayIndex, viewCellsData, groups, groupOrientation);\n    var targetType = cellType(targetData);\n    var insidePart = calculateInsidePart(clientOffset.y, tableCellElementsMeta.getCellRects, timeTableIndex);\n    var cellDurationMinutes = intervalDuration(targetData, 'minutes');\n\n    var _d = calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, this.offsetTimeTop),\n        appointmentStartTime = _d.appointmentStartTime,\n        appointmentEndTime = _d.appointmentEndTime,\n        offsetTimeTop = _d.offsetTimeTop;\n\n    var appointmentGroups = calculateAppointmentGroups(targetData.groupingInfo, resources, payload);\n    this.appointmentStartTime = appointmentStartTime || this.appointmentStartTime;\n    this.appointmentEndTime = appointmentEndTime || this.appointmentEndTime;\n    this.appointmentGroupingInfo = appointmentGroups || this.appointmentGroupingInfo;\n    this.offsetTimeTop = offsetTimeTop;\n    var _e = this.state,\n        startTime = _e.startTime,\n        endTime = _e.endTime,\n        appointmentGroupingInfo = _e.appointmentGroupingInfo;\n\n    if (!appointmentDragged(this.appointmentStartTime, startTime, this.appointmentEndTime, endTime, this.appointmentGroupingInfo, appointmentGroupingInfo)) {\n      return;\n    }\n\n    var draftAppointments = [{\n      dataItem: _assign(_assign(_assign({}, payload), {\n        startDate: this.appointmentStartTime,\n        endDate: this.appointmentEndTime\n      }), this.appointmentGroupingInfo),\n      start: this.appointmentStartTime,\n      end: this.appointmentEndTime\n    }];\n\n    var _f = calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, allDayCellsElementsMeta, targetType, cellDurationMinutes, tableCellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name)),\n        allDayDraftAppointments = _f.allDayDraftAppointments,\n        timeTableDraftAppointments = _f.timeTableDraftAppointments;\n\n    this.allDayDraftAppointments = allDayDraftAppointments;\n    this.timeTableDraftAppointments = timeTableDraftAppointments;\n    this.applyChanges(this.appointmentStartTime, this.appointmentEndTime, payload, startEditAppointment, changeAppointment, this.appointmentGroupingInfo);\n  };\n\n  DragDropProviderBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.state,\n        payload = _a.payload,\n        appointmentContentTemplateKey = _a.appointmentContentTemplateKey,\n        appointmentBottomTemplateKey = _a.appointmentBottomTemplateKey,\n        appointmentTopTemplateKey = _a.appointmentTopTemplateKey;\n    var _b = this.props,\n        Container = _b.containerComponent,\n        DraftAppointment = _b.draftAppointmentComponent,\n        SourceAppointment = _b.sourceAppointmentComponent,\n        Resize = _b.resizeComponent,\n        allowDrag = _b.allowDrag,\n        allowResize = _b.allowResize;\n\n    var draftData = _assign(_assign({}, payload), {\n      startDate: this.appointmentStartTime,\n      endDate: this.appointmentEndTime\n    });\n\n    return createElement(Plugin, {\n      name: \"DragDropProvider\",\n      dependencies: pluginDependencies$6\n    }, createElement(Template, {\n      name: \"body\"\n    }, createElement(TemplateConnector, null, function (_a, _b) {\n      var viewCellsData = _a.viewCellsData,\n          startViewDate = _a.startViewDate,\n          endViewDate = _a.endViewDate,\n          excludedDays = _a.excludedDays,\n          timeTableElementsMeta = _a.timeTableElementsMeta,\n          allDayElementsMeta = _a.allDayElementsMeta,\n          scrollingStrategy = _a.scrollingStrategy,\n          grouping = _a.grouping,\n          resources = _a.resources,\n          groups = _a.groups,\n          currentView = _a.currentView,\n          groupByDate = _a.groupByDate,\n          groupOrientation = _a.groupOrientation;\n      var changeAppointment = _b.changeAppointment,\n          startEditAppointment = _b.startEditAppointment,\n          finishCommitAppointment = _b.finishCommitAppointment;\n\n      var calculateBoundariesByMove = _this.calculateNextBoundaries({\n        viewCellsData: viewCellsData,\n        currentView: currentView,\n        startViewDate: startViewDate,\n        endViewDate: endViewDate,\n        excludedDays: excludedDays,\n        timeTableElementsMeta: timeTableElementsMeta,\n        allDayElementsMeta: allDayElementsMeta,\n        scrollingStrategy: scrollingStrategy,\n        resources: resources,\n        grouping: grouping,\n        groups: groups,\n        groupByDate: groupByDate,\n        groupOrientation: groupOrientation\n      }, {\n        changeAppointment: changeAppointment,\n        startEditAppointment: startEditAppointment\n      });\n\n      return createElement(DragDropProvider$1, {\n        onChange: _this.onPayloadChange({\n          finishCommitAppointment: finishCommitAppointment\n        })\n      }, createElement(DropTarget, {\n        onOver: calculateBoundariesByMove,\n        onEnter: calculateBoundariesByMove,\n        onDrop: _this.handleDrop({\n          finishCommitAppointment: finishCommitAppointment\n        }),\n        onLeave: _this.handleLeave\n      }, createElement(TemplatePlaceholder, null)));\n    })), createElement(Template, {\n      name: \"appointmentContent\",\n      predicate: function predicate(_a) {\n        var data = _a.data;\n        return allowDrag(data);\n      },\n      key: appointmentContentTemplateKey\n    }, function (_a) {\n      var styles = _a.styles,\n          params = __rest(_a, [\"styles\"]);\n\n      return createElement(DragSource, {\n        payload: _assign(_assign({}, params.data), {\n          type: params.type\n        })\n      }, payload && params.data.id === payload.id ? createElement(SourceAppointment, _assign({}, params)) : createElement(TemplatePlaceholder, {\n        params: _assign(_assign({}, params), {\n          draggable: true\n        })\n      }));\n    }), createElement(Template, {\n      name: \"appointmentTop\",\n      predicate: function predicate(params) {\n        return !params.slice && allowResize(params.data);\n      },\n      key: appointmentTopTemplateKey\n    }, function (_a) {\n      var data = _a.data,\n          type = _a.type;\n      return createElement(DragSource, {\n        payload: _assign(_assign({}, data), {\n          type: RESIZE_TOP,\n          appointmentType: type\n        })\n      }, createElement(Resize, {\n        position: POSITION_START,\n        appointmentType: type\n      }));\n    }), createElement(Template, {\n      name: \"appointmentBottom\",\n      predicate: function predicate(params) {\n        return !params.slice && allowResize(params.data);\n      },\n      key: appointmentBottomTemplateKey\n    }, function (_a) {\n      var data = _a.data,\n          type = _a.type;\n      return createElement(DragSource, {\n        payload: _assign(_assign({}, data), {\n          type: RESIZE_BOTTOM,\n          appointmentType: type\n        })\n      }, createElement(Resize, {\n        position: POSITION_END,\n        appointmentType: type\n      }));\n    }), createElement(Template, {\n      name: \"allDayPanel\"\n    }, createElement(TemplatePlaceholder, null), renderAppointmentItems(this.allDayDraftAppointments, Container, draftData)), createElement(Template, {\n      name: \"timeTable\"\n    }, createElement(TemplatePlaceholder, null), renderAppointmentItems(this.timeTableDraftAppointments, Container, draftData)), createElement(Template, {\n      name: \"draftAppointment\"\n    }, function (_a) {\n      var data = _a.data,\n          draftAppointment = _a.draftAppointment,\n          restParams = __rest(_a, [\"data\", \"draftAppointment\"]);\n\n      return createElement(TemplateConnector, null, function (_a) {\n        var formatDate = _a.formatDate,\n            resources = _a.resources,\n            plainResources = _a.plainResources;\n\n        var dataItem = draftAppointment.dataItem,\n            type = draftAppointment.type,\n            fromPrev = draftAppointment.fromPrev,\n            toNext = draftAppointment.toNext,\n            durationType = draftAppointment.durationType,\n            geometry = __rest(draftAppointment, [\"dataItem\", \"type\", \"fromPrev\", \"toNext\", \"durationType\"]);\n\n        return createElement(DraftAppointment, _assign({\n          data: data,\n          resources: getAppointmentResources(dataItem, resources, plainResources),\n          durationType: durationType,\n          style: getAppointmentStyle(geometry),\n          type: type,\n          fromPrev: fromPrev,\n          toNext: toNext,\n          formatDate: formatDate\n        }, restParams));\n      });\n    }));\n  };\n\n  DragDropProviderBase.components = {\n    containerComponent: 'Container',\n    draftAppointmentComponent: 'DraftAppointment',\n    sourceAppointmentComponent: 'SourceAppointment',\n    resizeComponent: 'Resize'\n  };\n  DragDropProviderBase.defaultProps = {\n    allowDrag: function allowDrag() {\n      return true;\n    },\n    allowResize: function allowResize() {\n      return true;\n    }\n  };\n  return DragDropProviderBase;\n}(PureComponent);\n/** A plugin that enables users to edit appointments via drag-and-drop. */\n\n\nvar DragDropProvider = DragDropProviderBase;\nvar pluginDependencies$7 = [{\n  name: 'Toolbar'\n}, {\n  name: 'ViewState'\n}];\nvar defaultMessages$2 = {\n  today: 'Today'\n};\n\nvar TodayButtonBase = /*#__PURE__*/function (_super) {\n  __extends(TodayButtonBase, _super);\n\n  function TodayButtonBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TodayButtonBase.prototype.render = function () {\n    var _a = this.props,\n        Button = _a.buttonComponent,\n        messages = _a.messages;\n    var getMessage = getMessagesFormatter(_assign(_assign({}, defaultMessages$2), messages));\n    return createElement(Plugin, {\n      name: \"TodayButton\",\n      dependencies: pluginDependencies$7\n    }, createElement(Template, {\n      name: \"toolbarContent\"\n    }, createElement(TemplateConnector, null, function (getters, _a) {\n      var changeCurrentDate = _a.changeCurrentDate;\n\n      var setCurrentDate = function setCurrentDate(nextDate) {\n        return changeCurrentDate({\n          nextDate: nextDate\n        });\n      };\n\n      return createElement(Button, {\n        getMessage: getMessage,\n        setCurrentDate: setCurrentDate\n      });\n    }), createElement(TemplatePlaceholder, null)));\n  };\n\n  TodayButtonBase.components = {\n    buttonComponent: 'Button'\n  };\n  return TodayButtonBase;\n}(PureComponent);\n/** A plugin that renders the Scheduler's button which sets the current date to today's date. */\n\n\nvar TodayButton = TodayButtonBase;\n\nvar _a;\n\nvar pluginDependencies$8 = [{\n  name: 'EditingState'\n}];\nvar defaultAvailableOperations = [{\n  value: RECURRENCE_EDIT_SCOPE.CURRENT\n}, {\n  value: RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING\n}, {\n  value: RECURRENCE_EDIT_SCOPE.ALL\n}];\nvar defaultMessages$3 = (_a = {}, _a[RECURRENCE_EDIT_SCOPE.CURRENT] = 'This appointment', _a[RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING] = 'This and following appointments', _a[RECURRENCE_EDIT_SCOPE.ALL] = 'All appointments', _a.menuEditingTitle = 'Edit recurring appointment', _a.menuDeletingTitle = 'Delete recurring appointment', _a.cancelButton = 'Cancel', _a.commitButton = 'OK', _a);\n\nvar EditRecurrenceMenuBase = /*#__PURE__*/function (_super) {\n  __extends(EditRecurrenceMenuBase, _super);\n\n  function EditRecurrenceMenuBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.modalContainer = createRef();\n    _this.state = {\n      isOpen: false,\n      deletedAppointmentData: null\n    };\n\n    _this.finishCommitAppointment = function (payload, _a, _b) {\n      var editingAppointment = _a.editingAppointment;\n      var commitChangedAppointment = _b.commitChangedAppointment;\n\n      if (editingAppointment && !editingAppointment.rRule) {\n        commitChangedAppointment();\n      } else {\n        _this.setState({\n          isOpen: true,\n          deletedAppointmentData: null\n        });\n      }\n    };\n\n    _this.finishDeleteAppointment = function (payload, getters, _a) {\n      var commitDeletedAppointment = _a.commitDeletedAppointment;\n\n      if (payload && !payload.rRule) {\n        commitDeletedAppointment({\n          deletedAppointmentData: payload\n        });\n      } else {\n        _this.setState({\n          isOpen: true,\n          deletedAppointmentData: payload\n        });\n      }\n    };\n\n    _this.commit = memoize(function (editAction, deleteAction, payload) {\n      return function (type) {\n        if (payload) {\n          deleteAction({\n            deletedAppointmentData: payload,\n            type: type\n          });\n        } else {\n          editAction(type);\n        }\n\n        _this.closeMenu();\n      };\n    });\n\n    _this.closeMenu = function () {\n      _this.setState({\n        isOpen: false,\n        deletedAppointmentData: null\n      });\n    };\n\n    _this.cancelEditing = memoize(function (cancelAction, stopEditAction) {\n      return function () {\n        stopEditAction();\n        cancelAction();\n\n        _this.closeMenu();\n      };\n    });\n    _this.availableOperations = memoize(function (getMessage, menuAvailableOperations) {\n      return menuAvailableOperations.map(function (_a) {\n        var value = _a.value;\n        return {\n          value: value,\n          title: getMessage([value])\n        };\n      });\n    });\n    _this.getMessage = memoize(function (messages, menuMessages) {\n      return getMessagesFormatter(_assign(_assign({}, menuMessages), messages));\n    });\n    return _this;\n  }\n\n  EditRecurrenceMenuBase.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.state,\n        isOpen = _a.isOpen,\n        deletedAppointmentData = _a.deletedAppointmentData;\n    var _b = this.props,\n        Layout = _b.layoutComponent,\n        Overlay = _b.overlayComponent,\n        Container = _b.containerComponent,\n        buttonComponent = _b.buttonComponent,\n        messages = _b.messages;\n    var getMessage = this.getMessage(messages, defaultMessages$3);\n    var availableOperations = this.availableOperations(getMessage, defaultAvailableOperations);\n    return createElement(Plugin, {\n      name: \"EditRecurrenceMenu\",\n      dependencies: pluginDependencies$8\n    }, createElement(Action, {\n      name: \"finishCommitAppointment\",\n      action: this.finishCommitAppointment\n    }), createElement(Action, {\n      name: \"finishDeleteAppointment\",\n      action: this.finishDeleteAppointment\n    }), createElement(Template, {\n      name: \"schedulerRoot\"\n    }, createElement(TemplatePlaceholder, null), createElement(Container, {\n      ref: this.modalContainer\n    }), createElement(TemplatePlaceholder, {\n      name: \"overlay\"\n    })), createElement(Template, {\n      name: \"overlay\"\n    }, createElement(TemplateConnector, null, function (getters, _a) {\n      var commitChangedAppointment = _a.commitChangedAppointment,\n          commitDeletedAppointment = _a.commitDeletedAppointment,\n          cancelChangedAppointment = _a.cancelChangedAppointment,\n          stopEditAppointment = _a.stopEditAppointment;\n\n      var commit = _this.commit(commitChangedAppointment, commitDeletedAppointment, deletedAppointmentData);\n\n      var cancelEditing = _this.cancelEditing(cancelChangedAppointment, stopEditAppointment);\n\n      return createElement(Overlay, {\n        target: _this.modalContainer,\n        visible: isOpen,\n        onHide: _this.closeMenu\n      }, createElement(Layout, {\n        isDeleting: !!deletedAppointmentData,\n        buttonComponent: buttonComponent,\n        handleClose: cancelEditing,\n        commit: commit,\n        availableOperations: availableOperations,\n        getMessage: getMessage\n      }));\n    })));\n  };\n\n  EditRecurrenceMenuBase.components = {\n    layoutComponent: 'Layout',\n    overlayComponent: 'Overlay',\n    buttonComponent: 'Button',\n    containerComponent: 'Container'\n  };\n  return EditRecurrenceMenuBase;\n}(PureComponent);\n/**\r\n * A plugin that renders the Scheduler's edit menu.\r\n * Should not be used with the `IntegratedEditing` plugin.\r\n */\n\n\nvar EditRecurrenceMenu = EditRecurrenceMenuBase;\nvar pluginDependencies$9 = [{\n  name: 'EditingState'\n}];\n\nvar IntegratedEditingBase = /*#__PURE__*/function (_super) {\n  __extends(IntegratedEditingBase, _super);\n\n  function IntegratedEditingBase() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.finishCommitAppointment = function (payload, getters, _a) {\n      var commitChangedAppointment = _a.commitChangedAppointment;\n      commitChangedAppointment();\n    };\n\n    _this.finishDeleteAppointment = function (payload, getters, _a) {\n      var commitDeletedAppointment = _a.commitDeletedAppointment;\n      commitDeletedAppointment({\n        deletedAppointmentData: payload\n      });\n    };\n\n    return _this;\n  }\n\n  IntegratedEditingBase.prototype.render = function () {\n    return createElement(Plugin, {\n      name: \"IntegratedEditing\",\n      dependencies: pluginDependencies$9\n    }, createElement(Action, {\n      name: \"finishCommitAppointment\",\n      action: this.finishCommitAppointment\n    }), createElement(Action, {\n      name: \"finishDeleteAppointment\",\n      action: this.finishDeleteAppointment\n    }));\n  };\n\n  IntegratedEditingBase.defaultProps = {\n    totalCount: 0\n  };\n  return IntegratedEditingBase;\n}(PureComponent);\n/** A plugin that allows implementing a editing calculation logic. */\n\n\nvar IntegratedEditing = IntegratedEditingBase;\nvar pluginDependencies$a = [{\n  name: 'Appointments'\n}];\n\nvar addResourcesToTimeTableAppointments = function addResourcesToTimeTableAppointments(_a) {\n  var timeTableAppointments = _a.timeTableAppointments,\n      resources = _a.resources,\n      plainResources = _a.plainResources;\n  return timeTableAppointments && addResourcesToAppointments(timeTableAppointments[0], resources, plainResources);\n};\n\nvar addResourcesToAllDayAppointments = function addResourcesToAllDayAppointments(_a) {\n  var allDayAppointments = _a.allDayAppointments,\n      resources = _a.resources,\n      plainResources = _a.plainResources;\n  return allDayAppointments && addResourcesToAppointments(allDayAppointments[0], resources, plainResources);\n};\n\nvar ResourcesBase = memo(function (_a) {\n  var data = _a.data,\n      mainResourceName = _a.mainResourceName,\n      palette = _a.palette;\n\n  var convertResources = function convertResources(_a) {\n    var resources = _a.resources;\n    return convertResourcesToPlain(resources);\n  };\n\n  return createElement(Plugin, {\n    name: \"Resources\",\n    dependencies: pluginDependencies$a\n  }, createElement(Getter, {\n    name: \"resources\",\n    value: validateResources(data, mainResourceName, palette)\n  }), createElement(Getter, {\n    name: \"plainResources\",\n    computed: convertResources\n  }), createElement(Getter, {\n    name: \"timeTableAppointments\",\n    computed: addResourcesToTimeTableAppointments\n  }), createElement(Getter, {\n    name: \"allDayAppointments\",\n    computed: addResourcesToAllDayAppointments\n  }));\n});\n/** A plugin that manages schedule's resources. */\n\nvar Resources = ResourcesBase;\nvar defaultMessages$4 = {\n  discardButton: 'Discard',\n  deleteButton: 'Delete',\n  cancelButton: 'Cancel',\n  confirmDeleteMessage: 'Are you sure you want to delete this appointment?',\n  confirmCancelMessage: 'Discard unsaved changes?'\n};\nvar pluginDependencies$b = [{\n  name: 'EditingState'\n}, {\n  name: 'EditRecurrenceMenu',\n  optional: true\n}, {\n  name: 'IntegratedEditing',\n  optional: true\n}];\nvar ACTION_TYPES = {\n  CANCEL: 'cancel',\n  DELETE: 'delete'\n};\n\nvar ConfirmationDialogBase = function ConfirmationDialogBase(_a) {\n  var messages = _a.messages,\n      Overlay = _a.overlayComponent,\n      Layout = _a.layoutComponent,\n      Container = _a.containerComponent,\n      buttonComponent = _a.buttonComponent,\n      ignoreDelete = _a.ignoreDelete,\n      ignoreCancel = _a.ignoreCancel;\n  var getMessage = getMessagesFormatter(_assign(_assign({}, defaultMessages$4), messages));\n  var modalContainer = useRef();\n\n  var _b = __read(useState(false), 2),\n      visible = _b[0],\n      setVisible = _b[1];\n\n  var _c = __read(useState(''), 2),\n      actionType = _c[0],\n      setActionType = _c[1];\n\n  var _d = __read(useState(''), 2),\n      hideActionName = _d[0],\n      setHideActionName = _d[1];\n\n  var _e = __read(useState({}), 2),\n      appointmentData = _e[0],\n      setAppointmentData = _e[1];\n\n  var toggleVisibility = useCallback(function () {\n    setVisible(!visible);\n  }, [visible, setVisible]);\n  var confirmCancelChanges = useCallback(function (hideAction) {\n    toggleVisibility();\n    setHideActionName(hideAction);\n    setActionType(ACTION_TYPES.CANCEL);\n  }, [toggleVisibility, setHideActionName, setActionType]);\n  var confirmDelete = useCallback(function (_a) {\n    var hideAction = _a.hideActionName,\n        changedAppointment = _a.appointmentData;\n    toggleVisibility();\n    setHideActionName(hideAction);\n    setActionType(ACTION_TYPES.DELETE);\n    setAppointmentData(changedAppointment);\n  }, [toggleVisibility, setHideActionName, setActionType, setAppointmentData]);\n  var confirmAction = useCallback(function (isNewAppointment, hideEditor, stopEditAppointment, finishDeleteAppointment, cancelAddedAppointment, cancelChangedAppointment) {\n    return function () {\n      hideEditor();\n      toggleVisibility();\n\n      if (isNewAppointment) {\n        cancelAddedAppointment();\n      } else {\n        stopEditAppointment();\n        cancelChangedAppointment();\n      }\n\n      if (actionType === ACTION_TYPES.DELETE) {\n        finishDeleteAppointment(appointmentData);\n      }\n    };\n  }, [toggleVisibility, actionType, appointmentData]);\n  return createElement(Plugin, {\n    name: \"ConfirmationDialog\",\n    dependencies: pluginDependencies$b\n  }, !ignoreCancel && createElement(Action, {\n    name: \"openCancelConfirmationDialog\",\n    action: confirmCancelChanges\n  }), !ignoreDelete && createElement(Action, {\n    name: \"openDeleteConfirmationDialog\",\n    action: confirmDelete\n  }), createElement(Template, {\n    name: \"schedulerRoot\"\n  }, createElement(TemplatePlaceholder, null), createElement(Container, {\n    ref: modalContainer\n  }), createElement(TemplatePlaceholder, {\n    name: \"confirmationDialogOverlay\"\n  })), createElement(Template, {\n    name: \"confirmationDialogOverlay\"\n  }, createElement(TemplateConnector, null, function (_a, actions) {\n    var editingAppointment = _a.editingAppointment;\n    var handleConfirm = confirmAction(!editingAppointment, actions[hideActionName], actions.stopEditAppointment, actions.finishDeleteAppointment, actions.cancelAddedAppointment, actions.cancelChangedAppointment);\n    return createElement(Overlay, {\n      target: modalContainer,\n      visible: visible,\n      onHide: toggleVisibility\n    }, createElement(Layout, {\n      buttonComponent: buttonComponent,\n      handleCancel: toggleVisibility,\n      handleConfirm: handleConfirm,\n      getMessage: getMessage,\n      isDeleting: actionType === ACTION_TYPES.DELETE,\n      appointmentData: appointmentData\n    }));\n  })));\n};\n\nConfirmationDialogBase.components = {\n  overlayComponent: 'Overlay',\n  containerComponent: 'Container',\n  layoutComponent: 'Layout',\n  buttonComponent: 'Button'\n};\nConfirmationDialogBase.defaultProps = {\n  ignoreCancel: false,\n  ignoreDelete: false\n}; // tslint:disable-next-line: max-line-length\n\n/** A plugin that renders the dialog which allows users to confirm or to discard delete and cancel appointment actions. */\n\nvar ConfirmationDialog = ConfirmationDialogBase;\n\nvar GroupingStateBase = /*#__PURE__*/function (_super) {\n  __extends(GroupingStateBase, _super);\n\n  function GroupingStateBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.state = {\n      grouping: props.grouping,\n      expandedGroups: props.expandedGroups || props.defaultExpandedGroups\n    };\n    _this.stateHelper = createStateHelper(_this, {\n      expandedGroups: function expandedGroups() {\n        var onExpandedGroupsChange = _this.props.onExpandedGroupsChange;\n        return onExpandedGroupsChange;\n      }\n    });\n    _this.toggleGroupExpanded = _this.stateHelper.applyReducer.bind(_this.stateHelper, toggleExpandedGroups);\n    return _this;\n  }\n\n  GroupingStateBase.getDerivedStateFromProps = function (nextProps, prevState) {\n    var _a = nextProps.grouping,\n        grouping = _a === void 0 ? prevState.grouping : _a,\n        _b = nextProps.expandedGroups,\n        expandedGroups = _b === void 0 ? prevState.expandedGroups : _b;\n    return {\n      grouping: grouping,\n      expandedGroups: expandedGroups\n    };\n  };\n\n  GroupingStateBase.prototype.render = function () {\n    var _a = this.state,\n        grouping = _a.grouping,\n        expandedGroups = _a.expandedGroups;\n    var _b = this.props,\n        groupByDate = _b.groupByDate,\n        groupOrientation = _b.groupOrientation;\n    return createElement(Plugin, {\n      name: \"GroupingState\"\n    }, createElement(Getter, {\n      name: \"grouping\",\n      value: grouping\n    }), createElement(Getter, {\n      name: \"groupByDate\",\n      value: groupByDate\n    }), createElement(Getter, {\n      name: \"groupOrientation\",\n      value: groupOrientation\n    }), createElement(Getter, {\n      name: \"expandedGroups\",\n      value: expandedGroups\n    }), createElement(Action, {\n      name: \"toggleGroupExpanded\",\n      action: this.toggleGroupExpanded\n    }));\n  };\n\n  GroupingStateBase.defaultProps = {\n    defaultExpandedGroups: [],\n    groupByDate: function groupByDate() {\n      return false;\n    },\n    groupOrientation: function groupOrientation() {\n      return HORIZONTAL_GROUP_ORIENTATION;\n    }\n  };\n  return GroupingStateBase;\n}(PureComponent);\n/** A plugin that manages the grouping state. */\n\n\nvar GroupingState = GroupingStateBase;\nvar pluginDependencies$c = [{\n  name: 'GroupingState'\n}, {\n  name: 'IntegratedGrouping'\n}, {\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'MonthView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}, {\n  name: 'ViewState',\n  optional: true\n}];\n\nvar GroupingPanelBase = /*#__PURE__*/function (_super) {\n  __extends(GroupingPanelBase, _super);\n\n  function GroupingPanelBase() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  GroupingPanelBase.prototype.render = function () {\n    var _a = this.props,\n        HorizontalLayout = _a.horizontalLayoutComponent,\n        VerticalLayout = _a.verticalLayoutComponent,\n        rowComponent = _a.rowComponent,\n        cellComponent = _a.cellComponent,\n        allDayCellComponent = _a.allDayCellComponent;\n    return createElement(Plugin, {\n      name: \"GroupingPanel\",\n      dependencies: pluginDependencies$c\n    }, createElement(Template, {\n      name: \"groupingPanel\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var viewCellsData = _a.viewCellsData,\n          currentView = _a.currentView,\n          scrollingStrategy = _a.scrollingStrategy,\n          groupByDate = _a.groupByDate,\n          groupOrientation = _a.groupOrientation,\n          groups = _a.groups;\n      return groupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) === HORIZONTAL_GROUP_ORIENTATION ? createElement(HorizontalLayout, {\n        rowComponent: rowComponent,\n        cellComponent: cellComponent,\n        groups: groups,\n        colSpan: viewCellsData[0].length,\n        cellStyle: {\n          left: scrollingStrategy.fixedLeftWidth ? scrollingStrategy.fixedLeftWidth : (currentView === null || currentView === void 0 ? void 0 : currentView.type) === VIEW_TYPES.MONTH ? HORIZONTAL_VIEW_LEFT_OFFSET : VERTICAL_VIEW_LEFT_OFFSET\n        },\n        showHeaderForEveryDate: groupByDate === null || groupByDate === void 0 ? void 0 : groupByDate(currentView && currentView.name)\n      }) : createElement(VerticalLayout, {\n        rowComponent: rowComponent,\n        cellComponent: cellComponent,\n        groups: groups,\n        rowSpan: viewCellsData.length,\n        viewType: currentView === null || currentView === void 0 ? void 0 : currentView.type,\n        cellTextTopOffset: scrollingStrategy === null || scrollingStrategy === void 0 ? void 0 : scrollingStrategy.fixedTopHeight\n      });\n    })), createElement(Template, {\n      name: \"allDayGroupingPanel\"\n    }, createElement(TemplateConnector, null, function (_a) {\n      var groups = _a.groups,\n          currentView = _a.currentView,\n          groupOrientation = _a.groupOrientation;\n      return groupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) === VERTICAL_GROUP_ORIENTATION && createElement(VerticalLayout, {\n        rowComponent: rowComponent,\n        cellComponent: allDayCellComponent,\n        groups: groups,\n        rowSpan: groups[groups.length - 1].length,\n        viewType: VIEW_TYPES.ALL_DAY_PANEL\n      });\n    })));\n  };\n\n  GroupingPanelBase.components = {\n    horizontalLayoutComponent: 'HorizontalLayout',\n    verticalLayoutComponent: 'VerticalLayout',\n    rowComponent: 'Row',\n    cellComponent: 'Cell',\n    allDayCellComponent: 'AllDayCell'\n  };\n  return GroupingPanelBase;\n}(PureComponent);\n/** A plugin that renders the grouping panel used to display group names. */\n\n\nvar GroupingPanel = GroupingPanelBase;\nvar pluginDependencies$d = [{\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}, {\n  name: 'MonthView',\n  optional: true\n}, {\n  name: 'DragDropProvider',\n  optional: true\n}, {\n  name: 'Appointments',\n  optional: true\n}];\n\nvar CurrentTimeIndicatorBase = function CurrentTimeIndicatorBase(_a) {\n  var indicatorComponent = _a.indicatorComponent,\n      shadePreviousAppointments = _a.shadePreviousAppointments,\n      shadePreviousCells = _a.shadePreviousCells,\n      updateInterval = _a.updateInterval;\n\n  var _b = __read(useState(Date.now), 2),\n      currentTime = _b[0],\n      setCurrentTime = _b[1];\n\n  var _c = __read(useState(undefined), 2),\n      indicatorUpdateTimer = _c[0],\n      setIndicatorUpdateTimer = _c[1];\n\n  useEffect(function () {\n    clearInterval(indicatorUpdateTimer);\n    setIndicatorUpdateTimer(setInterval(function () {\n      setCurrentTime(Date.now());\n    }, updateInterval));\n    return function () {\n      return clearInterval(indicatorUpdateTimer);\n    };\n  }, [updateInterval]);\n  return createElement(Plugin, {\n    name: \"CurrentTimeIndicator\",\n    dependencies: pluginDependencies$d\n  }, createElement(Template, {\n    name: \"cell\",\n    predicate: function predicate(_a) {\n      var otherMonth = _a.otherMonth;\n      return !isMonthCell(otherMonth);\n    }\n  }, function (params) {\n    return createElement(TemplatePlaceholder, {\n      params: _assign(_assign({}, params), {\n        currentTimeIndicatorPosition: getCurrentTimeIndicatorTop(params, currentTime),\n        currentTimeIndicatorComponent: indicatorComponent\n      })\n    });\n  }), createElement(Template, {\n    name: \"cell\"\n  }, function (params) {\n    return createElement(TemplatePlaceholder, {\n      params: _assign(_assign({}, params), {\n        isShaded: isCellShaded(params, currentTime, shadePreviousCells)\n      })\n    });\n  }), createElement(Template, {\n    name: \"appointmentContent\"\n  }, function (params) {\n    return createElement(TemplatePlaceholder, {\n      params: _assign(_assign({}, params), {\n        isShaded: isShadedAppointment(params, currentTime, shadePreviousAppointments)\n      })\n    });\n  }), createElement(Template, {\n    name: \"draftAppointment\"\n  }, function (params) {\n    return createElement(TemplatePlaceholder, {\n      params: _assign(_assign({}, params), {\n        isShaded: isShadedAppointment(params, currentTime, shadePreviousAppointments)\n      })\n    });\n  }));\n};\n\nCurrentTimeIndicatorBase.defaultProps = {\n  updateInterval: 60000,\n  shadePreviousCells: false,\n  shadePreviousAppointments: false\n};\nCurrentTimeIndicatorBase.components = {\n  indicatorComponent: 'Indicator'\n}; // tslint:disable-next-line: max-line-length\n\n/** A plugin that renders the current time indicator and the shading that covers appointments and timetable cells up to the current time. */\n\nvar CurrentTimeIndicator = CurrentTimeIndicatorBase;\nvar pluginDependencies$e = [{\n  name: 'Resources'\n}, {\n  name: 'GroupingState'\n}, {\n  name: 'DayView',\n  optional: true\n}, {\n  name: 'MonthView',\n  optional: true\n}, {\n  name: 'WeekView',\n  optional: true\n}];\n\nvar getViewCellsDataComputed = function getViewCellsDataComputed(_a) {\n  var viewCellsData = _a.viewCellsData,\n      groups = _a.groups,\n      resourcesToGroupBy = _a.resourcesToGroupBy,\n      groupByDate = _a.groupByDate,\n      currentView = _a.currentView,\n      groupOrientation = _a.groupOrientation;\n  return expandViewCellsDataWithGroups(viewCellsData, groups, resourcesToGroupBy, groupByDate(currentView.name), groupOrientation(currentView.name));\n};\n\nvar getGroupsComputed = function getGroupsComputed(_a) {\n  var resourcesToGroupBy = _a.resourcesToGroupBy;\n  return getGroupsFromResources(resourcesToGroupBy);\n};\n\nvar getResourcesToGroupByComputed = function getResourcesToGroupByComputed(_a) {\n  var resources = _a.resources,\n      grouping = _a.grouping;\n  return sortFilteredResources(filterResourcesByGrouping(resources, grouping), grouping);\n};\n\nvar getGroupingComputed = function getGroupingComputed(_a) {\n  var grouping = _a.grouping,\n      resources = _a.resources;\n  return updateGroupingWithMainResource(grouping, resources);\n};\n\nvar getTimeTableAppointmentsComputed = function getTimeTableAppointmentsComputed(_a) {\n  var timeTableAppointments = _a.timeTableAppointments,\n      grouping = _a.grouping,\n      resourcesToGroupBy = _a.resourcesToGroupBy,\n      groups = _a.groups,\n      groupByDate = _a.groupByDate,\n      currentView = _a.currentView,\n      excludedDays = _a.excludedDays;\n  return timeTableAppointments && expandGroups(timeTableAppointments, grouping, resourcesToGroupBy, groups, excludedDays, groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name) && (currentView === null || currentView === void 0 ? void 0 : currentView.type) === VIEW_TYPES.MONTH);\n};\n\nvar getAllDayAppointmentsComputed = function getAllDayAppointmentsComputed(_a) {\n  var allDayAppointments = _a.allDayAppointments,\n      grouping = _a.grouping,\n      resourcesToGroupBy = _a.resourcesToGroupBy,\n      groups = _a.groups,\n      groupByDate = _a.groupByDate,\n      currentView = _a.currentView,\n      excludedDays = _a.excludedDays;\n  return allDayAppointments && expandGroups(allDayAppointments, grouping, resourcesToGroupBy, groups, excludedDays, groupByDate(currentView === null || currentView === void 0 ? void 0 : currentView.name));\n};\n\nvar getGroupByDateComputed = function getGroupByDateComputed(_a) {\n  var currentView = _a.currentView,\n      groupByDate = _a.groupByDate,\n      groupOrientation = _a.groupOrientation;\n  return groupOrientation(currentView === null || currentView === void 0 ? void 0 : currentView.name) === VERTICAL_GROUP_ORIENTATION ? function () {\n    return false;\n  } : groupByDate;\n};\n\nvar IntegratedGroupingBase = memo(function () {\n  return createElement(Plugin, {\n    name: \"IntegratedGrouping\",\n    dependencies: pluginDependencies$e\n  }, createElement(Getter, {\n    name: \"groupByDate\",\n    computed: getGroupByDateComputed\n  }), createElement(Getter, {\n    name: \"grouping\",\n    computed: getGroupingComputed\n  }), createElement(Getter, {\n    name: \"resourcesToGroupBy\",\n    computed: getResourcesToGroupByComputed\n  }), createElement(Getter, {\n    name: \"groups\",\n    computed: getGroupsComputed\n  }), createElement(Getter, {\n    name: \"viewCellsData\",\n    computed: getViewCellsDataComputed\n  }), createElement(Getter, {\n    name: \"timeTableAppointments\",\n    computed: getTimeTableAppointmentsComputed\n  }), createElement(Getter, {\n    name: \"allDayAppointments\",\n    computed: getAllDayAppointmentsComputed\n  }));\n});\n/** A plugin that implements grouping. */\n\nvar IntegratedGrouping = IntegratedGroupingBase;\nexport { AllDayPanel, AppointmentForm, AppointmentTooltip, Appointments, ConfirmationDialog, CurrentTimeIndicator, DateNavigator, DayView, DragDropProvider, EditRecurrenceMenu, EditingState, GroupingPanel, GroupingState, IntegratedEditing, IntegratedGrouping, MonthView, Resources, Scheduler, TodayButton, Toolbar, ViewState, ViewSwitcher, WeekView };","map":null,"metadata":{},"sourceType":"module"}