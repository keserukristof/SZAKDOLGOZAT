{"ast":null,"code":"/**\n * Bundle of @devexpress/dx-scheduler-core\n * Generated: 2020-03-04\n * Version: 2.5.0\n * License: https://js.devexpress.com/Licensing\n */\nimport moment from 'moment';\nimport { RRuleSet, RRule } from 'rrule';\nimport { slice } from '@devexpress/dx-core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return _assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) {\n    ar = ar.concat(__read(arguments[i]));\n  }\n\n  return ar;\n}\n\nvar VERTICAL_TYPE = 'vertical';\nvar HORIZONTAL_TYPE = 'horizontal';\nvar SCROLL_OFFSET = 50;\nvar SCROLL_SPEED_PX = 30;\nvar SECONDS = 'seconds';\nvar MINUTES = 'minutes';\nvar HOURS = 'hours';\nvar RESIZE_TOP = 'resize-start';\nvar RESIZE_BOTTOM = 'resize-end';\nvar POSITION_START = 'start';\nvar POSITION_END = 'end';\nvar AUTO_HEIGHT = 'auto';\nvar DAY_OPTIONS = {\n  day: 'numeric'\n};\nvar WEEK_DAY_OPTIONS = {\n  weekday: 'short'\n};\nvar SHORT_MONTH_OPTIONS = {\n  month: 'short'\n};\nvar HOUR_MINUTE_OPTIONS = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\nvar MONTH_YEAR_OPTIONS = {\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'short'\n};\nvar SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  month: 'short',\n  year: 'numeric'\n};\nvar SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  month: 'short',\n  year: '2-digit'\n};\nvar DAY_LONG_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'long',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_LONG_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: 'numeric'\n};\nvar DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS = {\n  day: 'numeric',\n  month: 'short',\n  year: '2-digit'\n};\nvar LONG_WEEK_DAY_OPTIONS = {\n  weekday: 'long'\n};\nvar LONG_MONTH_OPTIONS = {\n  month: 'long'\n};\nvar DAY_LONG_MONTH_OPTIONS = {\n  day: 'numeric',\n  month: 'long'\n};\nvar EMPTY_OPTIONS = {};\nvar RECURRENCE_EDIT_SCOPE = {\n  ALL: 'all',\n  CURRENT_AND_FOLLOWING: 'currentAndFollowing',\n  CURRENT: 'current'\n};\nvar TOGGLE_APPOINTMENT_FORM_VISIBILITY = 'toggleAppointmentFormVisibility';\nvar TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY = 'toggleAppointmentTooltipVisibility';\nvar WEEKDAY_INTERVAL = 'weekdayInterval';\nvar VERTICAL_VIEW_LEFT_OFFSET = 80;\nvar HORIZONTAL_VIEW_LEFT_OFFSET = 0;\nvar VERTICAL_GROUP_ORIENTATION = 'Vertical';\nvar HORIZONTAL_GROUP_ORIENTATION = 'Horizontal';\nvar VIEW_TYPES = {\n  MONTH: 'month',\n  WEEK: 'week',\n  DAY: 'day',\n  ALL_DAY_PANEL: 'allDayPanel'\n};\n\nvar computed = function computed(getters, viewName, baseComputed, defaultValue) {\n  if (getters.currentView.name !== viewName && !!defaultValue) {\n    return defaultValue;\n  }\n\n  return baseComputed(getters, viewName);\n};\n\nvar appointmentHeightType = function appointmentHeightType(appointment, cellDuration) {\n  var durationRatio = appointment.end.clone().diff(appointment.start, 'minutes') / cellDuration;\n  if (durationRatio === 1) return 'middle';\n  if (durationRatio > 1) return 'long';\n  return 'short';\n};\n\nvar toPercentage = function toPercentage(value, total) {\n  return value * 100 / total;\n};\n\nvar createExcludedInterval = function createExcludedInterval(day, start) {\n  var leftBound = moment(start.day(day));\n  return [leftBound, moment(leftBound).hour(start.hour()).endOf('day')];\n};\n\nvar excludedIntervals = function excludedIntervals(excludedDays, start) {\n  return excludedDays.map(function (day) {\n    return day === 0 ? 7 : day;\n  }).sort(function (a, b) {\n    return a - b;\n  }).reduce(function (acc, day, i, allDays) {\n    if (i && day === allDays[i - 1] + 1) {\n      acc[acc.length - 1][1].day(day);\n    } else {\n      acc.push(createExcludedInterval(day, start));\n    }\n\n    return acc;\n  }, []);\n};\n\nvar byDayPredicate = function byDayPredicate(boundary, date) {\n  return boundary.isSameOrAfter(date, 'day') && !boundary.isSame(boundary.clone().startOf('day'));\n};\n\nvar inInterval = function inInterval(date, interval) {\n  return date.isBetween(interval[0], interval[1], undefined, '[]');\n};\n\nvar viewPredicate = function viewPredicate(appointment, left, right, excludedDays, removeAllDayAppointments) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  if (removeAllDayAppointments === void 0) {\n    removeAllDayAppointments = false;\n  }\n\n  var start = appointment.start,\n      end = appointment.end;\n  var isAppointmentInBoundary = end.isAfter(left) && start.isBefore(right);\n  var isAppointmentInExcludedDays = !!excludedIntervals(excludedDays, moment(left)).find(function (interval) {\n    return inInterval(start, interval) && inInterval(end, interval);\n  });\n  var considerAllDayAppointment = removeAllDayAppointments ? moment(end).diff(start, 'hours') < 24 && !appointment.allDay : true;\n  return isAppointmentInBoundary && !isAppointmentInExcludedDays && considerAllDayAppointment;\n};\n\nvar compareByDay = function compareByDay(first, second) {\n  if (first.start.isBefore(second.start, 'day')) return -1;\n  if (first.start.isAfter(second.start, 'day')) return 1;\n  return 0;\n};\n\nvar compareByAllDay = function compareByAllDay(first, second) {\n  if (first.allDay && !second.allDay) return -1;\n  if (!first.allDay && second.allDay) return 1;\n  return 0;\n};\n\nvar compareByTime = function compareByTime(first, second) {\n  if (first.start.isBefore(second.start)) return -1;\n  if (first.start.isAfter(second.start)) return 1;\n  if (first.end.isBefore(second.end)) return 1;\n  if (first.end.isAfter(second.end)) return -1;\n  return 0;\n};\n\nvar sortAppointments = function sortAppointments(appointments) {\n  return appointments.slice().sort(function (a, b) {\n    return compareByDay(a, b) || compareByAllDay(a, b) || compareByTime(a, b);\n  });\n};\n\nvar findOverlappedAppointments = function findOverlappedAppointments(sortedAppointments, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  var appointments = sortedAppointments.slice();\n  var groups = [];\n  var totalIndex = 0;\n\n  while (totalIndex < appointments.length) {\n    groups.push([]);\n    var current = appointments[totalIndex];\n    var currentGroup = groups[groups.length - 1];\n    var next = appointments[totalIndex + 1];\n    var maxBoundary = current.end;\n    currentGroup.push(current);\n    totalIndex += 1;\n\n    while (next && (maxBoundary.isAfter(next.start) || byDay && byDayPredicate(maxBoundary, next.start))) {\n      currentGroup.push(next);\n      if (maxBoundary.isBefore(next.end)) maxBoundary = next.end;\n      totalIndex += 1;\n      next = appointments[totalIndex];\n    }\n  }\n\n  return groups;\n};\n\nvar isMidnight = function isMidnight(date) {\n  return date.isSame(date.clone().startOf('day'));\n};\n\nvar maxBoundaryPredicate = function maxBoundaryPredicate(maxBoundary, startDate) {\n  return maxBoundary.isBefore(startDate, 'day') || isMidnight(maxBoundary) && maxBoundary.isSame(startDate, 'day');\n};\n\nvar adjustAppointments = function adjustAppointments(groups, byDay) {\n  if (byDay === void 0) {\n    byDay = false;\n  }\n\n  return groups.map(function (items) {\n    var offset = 0;\n    var reduceValue = 1;\n    var appointments = items.map(function (appointment) {\n      return _assign({}, appointment);\n    });\n    var groupLength = appointments.length;\n\n    for (var startIndex = 0; startIndex < groupLength; startIndex += 1) {\n      var appointment = appointments[startIndex];\n\n      if (appointment.offset === undefined) {\n        var maxBoundary = appointment.end;\n        appointment.offset = offset;\n\n        for (var index = startIndex + 1; index < groupLength; index += 1) {\n          if (appointments[index].offset === undefined) {\n            if (!byDay && maxBoundary.isSameOrBefore(appointments[index].start) || byDay && maxBoundaryPredicate(maxBoundary, appointments[index].start)) {\n              maxBoundary = appointments[index].end;\n              appointments[index].offset = offset;\n            }\n          }\n        }\n\n        offset += 1;\n        if (reduceValue < offset) reduceValue = offset;\n      }\n    }\n\n    return {\n      items: appointments,\n      reduceValue: reduceValue\n    };\n  });\n};\n\nvar calculateFirstDateOfWeek = function calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var currentLocale = moment.locale();\n  moment.updateLocale('tmp-locale', {\n    week: {\n      dow: firstDayOfWeek,\n      doy: 1\n    }\n  });\n  var firstDateOfWeek = moment(currentDate).startOf('week');\n\n  if (excludedDays.indexOf(firstDayOfWeek) !== -1) {\n    excludedDays.slice().sort().forEach(function (day) {\n      if (day === firstDateOfWeek.day()) {\n        firstDateOfWeek.add(1, 'days');\n      }\n    });\n  }\n\n  moment.locale(currentLocale);\n  return firstDateOfWeek.toDate();\n};\n\nvar unwrapGroups = function unwrapGroups(groups) {\n  return groups.reduce(function (acc, _a) {\n    var items = _a.items,\n        reduceValue = _a.reduceValue;\n    acc.push.apply(acc, __spread(items.map(function (_a) {\n      var start = _a.start,\n          end = _a.end,\n          dataItem = _a.dataItem,\n          offset = _a.offset,\n          resources = _a.resources,\n          restProps = __rest(_a, [\"start\", \"end\", \"dataItem\", \"offset\", \"resources\"]);\n\n      return _assign({\n        start: start,\n        end: end,\n        dataItem: dataItem,\n        offset: offset,\n        reduceValue: reduceValue,\n        resources: resources,\n        fromPrev: moment(start).diff(dataItem.startDate, 'minutes') > 1,\n        toNext: moment(dataItem.endDate).diff(end, 'minutes') > 1\n      }, restProps);\n    })));\n    return acc;\n  }, []);\n};\n\nvar getAppointmentStyle = function getAppointmentStyle(_a) {\n  var top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n  return {\n    height: height,\n    width: width + \"%\",\n    transform: \"translateY(\" + top + \"px)\",\n    msTransform: \"translateY(\" + top + \"px)\",\n    left: left + \"%\",\n    position: 'absolute'\n  };\n};\n\nvar rectCalculatorBase = function rectCalculatorBase(appointment, viewMetaData, getRectByAppointment, options) {\n  return getRectByAppointment(appointment, viewMetaData, options);\n};\n\nvar horizontalRectCalculator = function horizontalRectCalculator(appointment, viewMetaData, _a) {\n  var rectByDates = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      cellElementsMeta = _b.cellElementsMeta,\n      viewCellsData = _b.viewCellsData;\n\n  var _c = rectCalculatorBase(appointment, viewMetaData, rectByDates, {\n    multiline: multiline,\n    cellElementsMeta: cellElementsMeta,\n    viewCellsData: viewCellsData\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  return {\n    resources: appointment.resources,\n    top: top + height / appointment.reduceValue * appointment.offset,\n    height: height / appointment.reduceValue,\n    left: toPercentage(left, parentWidth),\n    width: toPercentage(width, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    type: HORIZONTAL_TYPE\n  };\n};\n\nvar verticalRectCalculator = function verticalRectCalculator(appointment, viewMetaData, _a) {\n  var rectByDates = _a.rectByDates,\n      multiline = _a.multiline,\n      _b = _a.rectByDatesMeta,\n      viewCellsData = _b.viewCellsData,\n      cellDuration = _b.cellDuration,\n      cellElementsMeta = _b.cellElementsMeta,\n      excludedDays = _b.excludedDays;\n\n  var _c = rectCalculatorBase(appointment, viewMetaData, rectByDates, {\n    multiline: multiline,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    excludedDays: excludedDays,\n    cellElementsMeta: cellElementsMeta\n  }),\n      top = _c.top,\n      left = _c.left,\n      width = _c.width,\n      height = _c.height,\n      parentWidth = _c.parentWidth;\n\n  var widthInPx = width / appointment.reduceValue;\n  return {\n    resources: appointment.resources,\n    top: top,\n    height: height,\n    left: toPercentage(left + widthInPx * appointment.offset, parentWidth),\n    width: toPercentage(widthInPx, parentWidth),\n    dataItem: appointment.dataItem,\n    fromPrev: appointment.fromPrev,\n    toNext: appointment.toNext,\n    durationType: appointmentHeightType(appointment, cellDuration),\n    type: VERTICAL_TYPE\n  };\n};\n\nvar calculateRectByDateAndGroupIntervals = function calculateRectByDateAndGroupIntervals(type, intervals, rectByDates, rectByDatesMeta, viewMetaData) {\n  var growDirection = type.growDirection,\n      multiline = type.multiline;\n  var isHorizontal = growDirection === HORIZONTAL_TYPE;\n  var sorted = intervals.map(sortAppointments);\n  var grouped = sorted.reduce(function (acc, sortedGroup) {\n    return __spread(acc, findOverlappedAppointments(sortedGroup, isHorizontal));\n  }, []);\n  var rectCalculator = isHorizontal ? horizontalRectCalculator : verticalRectCalculator;\n  return unwrapGroups(adjustAppointments(grouped, isHorizontal)).map(function (appointment) {\n    return rectCalculator(appointment, viewMetaData, {\n      rectByDates: rectByDates,\n      multiline: multiline,\n      rectByDatesMeta: rectByDatesMeta\n    });\n  });\n};\n\nvar expandRecurrenceAppointment = function expandRecurrenceAppointment(appointment, leftBound, rightBound) {\n  var rightBoundUTC = moment(getUTCDate(rightBound)).toDate();\n  var leftBoundUTC = moment(getUTCDate(leftBound)).toDate();\n  var appointmentStartDate = moment(appointment.start).toDate();\n\n  var options = _assign(_assign({}, RRule.parseString(appointment.rRule)), {\n    dtstart: moment(getUTCDate(appointmentStartDate)).toDate()\n  });\n\n  var correctedOptions = options.until ? _assign(_assign({}, options), {\n    until: moment(getUTCDate(options.until)).toDate()\n  }) : options;\n  var rruleSet = getRRuleSetWithExDates(appointment.exDate);\n  rruleSet.rrule(new RRule(correctedOptions)); // According to https://github.com/jakubroztocil/rrule#important-use-utc-dates\n  // we have to format the dates we get from RRuleSet to get local dates\n\n  var datesInBoundaries = rruleSet.between(leftBoundUTC, rightBoundUTC, true).map(formatDateToString);\n  if (datesInBoundaries.length === 0) return [];\n  var appointmentDuration = moment(appointment.end).diff(appointment.start, 'minutes');\n  return datesInBoundaries.map(function (startDate, index) {\n    return _assign(_assign({}, appointment), {\n      dataItem: _assign(_assign({}, appointment.dataItem), {\n        startDate: moment(startDate).toDate(),\n        endDate: moment(startDate).add(appointmentDuration, 'minutes').toDate(),\n        parentData: appointment.dataItem\n      }),\n      start: moment(startDate),\n      end: moment(startDate).add(appointmentDuration, 'minutes')\n    });\n  });\n};\n\nvar filterByViewBoundaries = function filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, removeAllDay) {\n  var appointments = [appointment];\n\n  if (appointment.rRule) {\n    appointments = expandRecurrenceAppointment(appointment, leftBound, rightBound);\n  }\n\n  return appointments.filter(function (appt) {\n    return viewPredicate(appt, leftBound, rightBound, excludedDays, removeAllDay);\n  });\n};\n\nvar getUTCDate = function getUTCDate(date) {\n  return Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes());\n};\n\nvar getRRuleSetWithExDates = function getRRuleSetWithExDates(exDate) {\n  var rruleSet = new RRuleSet();\n\n  if (exDate) {\n    exDate.split(',').map(function (date) {\n      var currentExDate = moment(date).toDate();\n      rruleSet.exdate(moment(getUTCDate(currentExDate)).toDate());\n    });\n  }\n\n  return rruleSet;\n};\n\nvar formatDateToString = function formatDateToString(date) {\n  return moment.utc(date).format('YYYY-MM-DDTHH:mm');\n};\n\nvar MONTH_TYPE = 'month';\n\nvar getViewType = function getViewType(currentViewType) {\n  if (currentViewType === MONTH_TYPE) return HORIZONTAL_TYPE;\n  return VERTICAL_TYPE;\n};\n\nvar isMidnight$1 = function isMidnight$1(date) {\n  var momentDate = moment(date);\n  return momentDate.hours() === 0 && momentDate.minutes() === 0 && momentDate.seconds() === 0;\n};\n\nvar calculateTextByDays = function calculateTextByDays(startViewDate, endViewDate, formatDate, additionalOptions) {\n  var momentStartViewDate = moment(startViewDate);\n  var momentEndViewDate = moment(endViewDate);\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'day')) {\n    return formatDate(momentStartViewDate.toDate(), _assign(_assign({}, DAY_LONG_MONTH_LONG_YEAR_OPTIONS), additionalOptions));\n  }\n\n  if (momentStartViewDate.isSame(momentEndViewDate, 'year')) {\n    if (momentStartViewDate.isSame(momentEndViewDate, 'month')) {\n      return formatDate(momentStartViewDate.toDate(), DAY_OPTIONS) + \"-\" + formatDate(momentEndViewDate.toDate(), DAY_OPTIONS) + \" \" + formatDate(momentEndViewDate.toDate(), MONTH_YEAR_OPTIONS);\n    }\n\n    return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentStartViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(momentEndViewDate.toDate(), DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar calculateTextByMonths = function calculateTextByMonths(currentDate, intervalCount, formatDate) {\n  var momentCurrentDate = moment(currentDate);\n\n  if (intervalCount === 1) {\n    return formatDate(momentCurrentDate.toDate(), MONTH_YEAR_OPTIONS);\n  }\n\n  var lastMonth = momentCurrentDate.clone().add(intervalCount - 1, 'month');\n\n  if (momentCurrentDate.isSame(lastMonth, 'year')) {\n    return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_OPTIONS) + \"-\" + formatDate(lastMonth.toDate(), SHORT_MONTH_LONG_YEAR_OPTIONS);\n  }\n\n  return formatDate(momentCurrentDate.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS) + \" - \" + formatDate(lastMonth.toDate(), SHORT_MONTH_SHORT_YEAR_OPTIONS);\n};\n\nvar viewBoundText = function viewBoundText(startViewDate, endViewDate, type, currentDate, intervalCount, formatDate) {\n  return type !== 'month' ? calculateTextByDays(startViewDate, endViewDate, formatDate, type === WEEKDAY_INTERVAL ? LONG_WEEK_DAY_OPTIONS : EMPTY_OPTIONS) : calculateTextByMonths(currentDate, intervalCount, formatDate);\n};\n\nvar checkCellGroupingInfo = function checkCellGroupingInfo(cell, appointment) {\n  return cell.groupingInfo ? cell.groupingInfo.every(function (group) {\n    return group.id === appointment[group.fieldName];\n  }) : true;\n};\n\nvar isDateValid = function isDateValid(date) {\n  return moment(date).isValid();\n};\n\nvar convertToMoment = function convertToMoment(date) {\n  return moment(date);\n};\n\nvar areDatesSame = function areDatesSame(firstDate, secondDate) {\n  return moment(firstDate).isSame(secondDate, 'date');\n};\n\nvar subtractSecond = function subtractSecond(date) {\n  return moment(date).subtract(1, 'second').toDate();\n};\n\nvar dayScale = function dayScale(currentDate, firstDayOfWeek, dayCount, excluded) {\n  if (excluded === void 0) {\n    excluded = [];\n  }\n\n  var result = [];\n  var date = firstDayOfWeek !== undefined ? moment(calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excluded)) : moment(currentDate);\n\n  for (var index = 0; index < dayCount; index += 1) {\n    if (excluded.findIndex(function (item) {\n      return item === date.day();\n    }) === -1) {\n      result.push(date.toDate());\n    }\n\n    date.add(1, 'days');\n  }\n\n  return result;\n};\n\nvar timeScale = function timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays) {\n  var result = [];\n  var startDateOfView = firstDayOfWeek !== undefined ? calculateFirstDateOfWeek(currentDate, firstDayOfWeek, excludedDays) : currentDate;\n  var left = moment(startDateOfView).startOf('day').add(startDayHour, 'hour');\n  var right = moment(startDateOfView).startOf('day').add(endDayHour, 'hour');\n\n  while (left.isBefore(right)) {\n    var startDate = left.toDate();\n    left.add(cellDuration, 'minutes');\n    result.push({\n      start: startDate,\n      end: left.toDate()\n    });\n  }\n\n  var timeScaleLastIndex = result.length - 1;\n\n  if (isMidnight$1(result[timeScaleLastIndex].end)) {\n    result[timeScaleLastIndex].end = subtractSecond(result[timeScaleLastIndex].end);\n  }\n\n  return result;\n};\n\nvar availableViews = function availableViews(views, viewName, viewDisplayName) {\n  if (!views) return [{\n    name: viewName,\n    displayName: viewDisplayName\n  }];\n\n  if (views.findIndex(function (view) {\n    return viewName === view.name;\n  }) === -1) {\n    var nextViews = views.slice();\n    nextViews.push({\n      name: viewName,\n      displayName: viewDisplayName\n    });\n    return nextViews;\n  }\n\n  return views;\n};\n\nvar viewCellsData = function viewCellsData(currentDate, firstDayOfWeek, dayCount, excludedDays, startDayHour, endDayHour, cellDuration, currTime) {\n  var days = dayScale(currentDate, firstDayOfWeek, dayCount, excludedDays);\n  var times = timeScale(currentDate, firstDayOfWeek, startDayHour, endDayHour, cellDuration, excludedDays);\n  var currentTime = moment(currTime);\n  return times.reduce(function (cellsAcc, time) {\n    var start = moment(time.start);\n    var end = moment(time.end);\n    var rowCells = days.reduce(function (rowAcc, day) {\n      var startDate = moment(day).hours(start.hours()).minutes(start.minutes()).toDate();\n      var endDate = moment(day).hours(end.hours()).minutes(end.minutes()).toDate();\n      var today = currentTime.isSame(startDate, 'day');\n      rowAcc.push({\n        startDate: startDate,\n        endDate: endDate,\n        today: today\n      });\n      return rowAcc;\n    }, []);\n    cellsAcc.push(rowCells);\n    return cellsAcc;\n  }, []);\n};\n\nvar allDayCells = function allDayCells(viewCells) {\n  return viewCells[0].map(function (cell) {\n    return {\n      startDate: moment(cell.startDate).startOf('day').toDate(),\n      endDate: moment(cell.startDate).add(1, 'day').startOf('day').toDate(),\n      groupingInfo: cell.groupingInfo,\n      endOfGroup: cell.endOfGroup\n    };\n  });\n};\n\nvar startViewDate = function startViewDate(viewCells) {\n  return moment(viewCells[0][0].startDate).toDate();\n};\n\nvar endViewDate = function endViewDate(viewCells) {\n  var lastRowIndex = viewCells.length - 1;\n  var lastCellIndex = viewCells[lastRowIndex].length - 1;\n  return subtractSecond(viewCells[lastRowIndex][lastCellIndex].endDate);\n};\n\nvar sliceAppointmentByDay = function sliceAppointmentByDay(appointment, cellDuration) {\n  var start = appointment.start,\n      end = appointment.end,\n      dataItem = appointment.dataItem;\n  if (start.isSame(end, 'day')) return [appointment];\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = start.clone().endOf('day').diff(start, 'minutes') < minDuration;\n  var isShortOnSecondDay = end.clone().diff(end.clone().startOf('day'), 'minutes') < minDuration;\n  return [isShortOnFirstDay ? {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day'),\n    dataItem: dataItem\n  } : {\n    start: start,\n    end: start.clone().endOf('day'),\n    dataItem: dataItem\n  }, isShortOnSecondDay ? {\n    start: end.clone().startOf('day'),\n    end: end.clone().startOf('day').add(minDuration, 'minutes'),\n    dataItem: dataItem\n  } : {\n    start: end.clone().startOf('day'),\n    end: end,\n    dataItem: dataItem\n  }];\n};\n\nvar dayBoundaryPredicate = function dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes());\n  if (appointment.end.isBefore(dayStart) || appointment.start.isAfter(dayEnd)) return false;\n  if (excludedDays.findIndex(function (day) {\n    return day === moment(appointment.start).day();\n  }) !== -1) return false;\n  return appointment.end.isAfter(startDayTime) && appointment.start.isBefore(endDayTime);\n};\n\nvar reduceAppointmentByDayBounds = function reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration) {\n  var dayStart = moment(leftBound);\n  var dayEnd = moment(rightBound);\n  var startDayTime = moment(appointment.start).hour(dayStart.hour()).minutes(dayStart.minutes()).seconds(dayStart.seconds());\n  var endDayTime = moment(appointment.start).hour(dayEnd.hour()).minutes(dayEnd.minutes()).seconds(dayEnd.seconds());\n  var minDuration = cellDuration / 2;\n  var isShortOnFirstDay = endDayTime.clone().diff(appointment.start, 'minutes') < minDuration;\n  var isShortOnSecondDay = appointment.end.clone().diff(startDayTime, 'minutes') < minDuration;\n\n  if (isShortOnFirstDay) {\n    return _assign(_assign({}, appointment), {\n      start: endDayTime.clone().add(-minDuration, 'minutes'),\n      end: endDayTime\n    });\n  }\n\n  if (isShortOnSecondDay) {\n    return _assign(_assign({}, appointment), {\n      start: startDayTime,\n      end: startDayTime.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign(_assign({}, appointment), appointment.start.isSameOrBefore(startDayTime) ? {\n    start: startDayTime\n  } : null), appointment.end.isSameOrAfter(endDayTime) ? {\n    end: endDayTime\n  } : null);\n};\n\nvar normalizeAppointmentDuration = function normalizeAppointmentDuration(appointment, cellDuration) {\n  var minDuration = cellDuration / 2;\n  var start = moment(appointment.start);\n  var end = moment(appointment.end);\n\n  if (end.diff(start, 'minutes') > minDuration) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: end\n    });\n  }\n\n  if (end.isSame(start.clone().add(minDuration, 'minutes'), 'day')) {\n    return _assign(_assign({}, appointment), {\n      start: start,\n      end: start.clone().add(minDuration, 'minutes')\n    });\n  }\n\n  return _assign(_assign({}, appointment), {\n    start: start.clone().endOf('day').add(-minDuration, 'minutes'),\n    end: start.clone().endOf('day')\n  });\n};\n\nvar getWeekVerticallyGroupedColumnIndex = function getWeekVerticallyGroupedColumnIndex(viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return moment(date).isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getWeekHorizontallyGroupedColumnIndex = function getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    var isCorrectGroup = checkCellGroupingInfo(timeCell, appointment);\n    return moment(date).isSame(timeCell.startDate, 'date') && isCorrectGroup;\n  });\n};\n\nvar getWeekVerticallyGroupedRowIndex = function getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) {\n  var timeTableHeight = viewCellsData.length / groupCount;\n  var timeTableRowIndex = getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  if (!viewCellsData[0][0].groupingInfo) return timeTableRowIndex;\n  var isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n\n  while (isWrongCell) {\n    timeTableRowIndex += timeTableHeight;\n    isWrongCell = !checkCellGroupingInfo(viewCellsData[timeTableRowIndex][columnIndex], appointment);\n  }\n\n  return timeTableRowIndex;\n};\n\nvar getWeekHorizontallyGroupedRowIndex = function getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev) {\n  return viewCellsData.findIndex(function (timeCell) {\n    return moment(date).isBetween(timeCell[columnIndex].startDate, timeCell[columnIndex].endDate, 'seconds', takePrev ? '(]' : '[)');\n  });\n};\n\nvar calculateWeekDateIntervals = function calculateWeekDateIntervals(appointments, leftBound, rightBound, // startViewDate, endViewDate\nexcludedDays, cellDuration) {\n  return [appointments.map(function (appointment) {\n    return normalizeAppointmentDuration(appointment, cellDuration);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, true));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByDay(appointment, cellDuration));\n  }, []).filter(function (appointment) {\n    return dayBoundaryPredicate(appointment, leftBound, rightBound, excludedDays);\n  }).map(function (appointment) {\n    return reduceAppointmentByDayBounds(appointment, leftBound, rightBound, cellDuration);\n  })];\n};\n\nvar CELL_GAP_PX = 10;\nvar CELL_BOUND_HORIZONTAL_OFFSET_PX = 1;\nvar CELL_BOUND_VERTICAL_OFFSET_PX = 4;\n\nvar getVerticalCellIndexByAppointmentData = function getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedColumnIndex(viewCellsData, date) : getWeekHorizontallyGroupedColumnIndex(viewCellsData, appointment, date);\n  var rowIndex = groupOrientation === VERTICAL_GROUP_ORIENTATION ? getWeekVerticallyGroupedRowIndex(viewCellsData, appointment, date, columnIndex, takePrev, groupCount) : getWeekHorizontallyGroupedRowIndex(viewCellsData, date, columnIndex, takePrev);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return {\n    index: cellIndex,\n    startDate: viewCellsData[rowIndex][columnIndex].startDate\n  };\n};\n\nvar getCellRect = function getCellRect(date, appointment, viewCellsData, cellDuration, cellElementsMeta, takePrev, viewMetaData) {\n  var _a = getVerticalCellIndexByAppointmentData(appointment, viewCellsData, viewMetaData, date, takePrev),\n      cellIndex = _a.index,\n      cellStartDate = _a.startDate;\n\n  var _b = cellElementsMeta.getCellRects[cellIndex](),\n      top = _b.top,\n      left = _b.left,\n      width = _b.width,\n      cellHeight = _b.height;\n\n  var timeOffset = moment(date).diff(cellStartDate, 'minutes');\n  var topOffset = cellHeight * (timeOffset / cellDuration);\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    topOffset: topOffset,\n    parentRect: parentRect\n  };\n};\n\nvar getVerticalRectByAppointmentData = function getVerticalRectByAppointmentData(appointment, viewMetaData, _a) {\n  var viewCellsData = _a.viewCellsData,\n      cellDuration = _a.cellDuration,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect(appointment.start.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, false, viewMetaData);\n  var lastCellRect = getCellRect(appointment.end.toDate(), appointment, viewCellsData, cellDuration, cellElementsMeta, true, viewMetaData);\n  var top = firstCellRect.top + firstCellRect.topOffset;\n  var height = lastCellRect.top + lastCellRect.topOffset - top;\n  return {\n    width: firstCellRect.width - CELL_GAP_PX - CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    top: top - firstCellRect.parentRect.top + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_HORIZONTAL_OFFSET_PX,\n    parentWidth: firstCellRect.parentRect.width,\n    height: height - CELL_BOUND_VERTICAL_OFFSET_PX\n  };\n};\n\nvar getGroupFromResourceInstance = function getGroupFromResourceInstance(resourceInstance) {\n  return {\n    id: resourceInstance.id,\n    fieldName: resourceInstance.fieldName,\n    text: resourceInstance.text\n  };\n};\n\nvar addGroupInfoToCells = function addGroupInfoToCells(currentGroup, groups, sortedResources, viewCellRow, index, endOfGroup, groupOrientation) {\n  return viewCellRow.map(function (viewCell, cellIndex) {\n    var groupedCell = addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation);\n    return cellIndex === viewCellRow.length - 1 && groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? _assign(_assign({}, groupedCell), {\n      endOfGroup: true\n    }) : groupedCell;\n  });\n};\n\nvar addGroupInfoToCell = function addGroupInfoToCell(currentGroup, groups, sortedResources, viewCell, index, endOfGroup, groupOrientation) {\n  var previousIndex = index;\n  var groupingInfo = groups.reduceRight(function (acc, group, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = sortedResources[currentIndex + 1].instances.length;\n    var currentGroupingInstance = group[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [currentGroup]);\n  return _assign(_assign({}, viewCell), {\n    groupingInfo: groupingInfo,\n    endOfGroup: endOfGroup,\n    groupOrientation: groupOrientation\n  });\n};\n\nvar getCurrentGroup = function getCurrentGroup(groups, resources, index, group) {\n  var currentIndex = index;\n  return groups.reduceRight(function (groupAcc, groupsRow, rowIndex) {\n    if (rowIndex === groups.length - 1) {\n      return groupAcc;\n    }\n\n    currentIndex = Math.floor(currentIndex / resources[rowIndex + 1].instances.length);\n    var currentInstance = groupsRow[currentIndex];\n    return __spread(groupAcc, [currentInstance]);\n  }, [group]);\n};\n\nvar groupAppointments = function groupAppointments(appointments, resources, groups) {\n  if (!resources || !groups) return [appointments.slice()];\n  var mainResource = resources.find(function (resource) {\n    return resource.isMain;\n  });\n  return groups[groups.length - 1].map(function (group, index) {\n    var currentGroup = getCurrentGroup(groups, resources, index, group);\n    return appointments.reduce(function (acc, appointment) {\n      var _a;\n\n      var belongsToGroup = currentGroup.reduce(function (isBelonging, groupItem) {\n        return isBelonging && groupItem.id === appointment[groupItem.fieldName];\n      }, true);\n      if (!belongsToGroup) return acc;\n      var currentMainResourceId = currentGroup.find(function (groupItem) {\n        return groupItem.fieldName === mainResource.fieldName;\n      }).id;\n\n      var updatedAppointment = _assign(_assign({}, appointment), {\n        dataItem: _assign(_assign({}, appointment.dataItem), (_a = {}, _a[mainResource.fieldName] = rearrangeResourceIds(mainResource, appointment, currentMainResourceId), _a)),\n        resources: appointment.resources && rearrangeResources(mainResource, appointment, currentMainResourceId)\n      });\n\n      return __spread(acc, [updatedAppointment]);\n    }, []);\n  });\n};\n\nvar rearrangeResourceIds = function rearrangeResourceIds(mainResource, appointment, mainResourceId) {\n  if (!mainResource.allowMultiple) {\n    return mainResourceId;\n  }\n\n  return __spread([mainResourceId], appointment.dataItem[mainResource.fieldName].filter(function (id) {\n    return id !== mainResourceId;\n  }));\n};\n\nvar rearrangeResources = function rearrangeResources(mainResource, appointment, currentResourceInstanceId) {\n  var _a;\n\n  if (!mainResource.allowMultiple) {\n    return appointment.resources;\n  }\n\n  var resources = appointment.resources.slice();\n  var firstMainResource = resources.findIndex(function (el) {\n    return el.isMain;\n  });\n  var currentResourceIndex = resources.findIndex(function (el) {\n    return el.isMain && el.id === currentResourceInstanceId;\n  });\n  _a = __read([resources[currentResourceIndex], resources[firstMainResource]], 2), resources[firstMainResource] = _a[0], resources[currentResourceIndex] = _a[1];\n  return resources;\n};\n\nvar expandGroupedAppointment = function expandGroupedAppointment(appointment, grouping, resources) {\n  if (!resources || !grouping) {\n    return [appointment];\n  }\n\n  return resources.reduce(function (acc, resource) {\n    var isGroupedByResource = grouping.find(function (group) {\n      return group.resourceName === resource.fieldName;\n    }) !== undefined;\n    if (!isGroupedByResource) return acc;\n    var resourceField = resource.fieldName;\n\n    if (!resource.allowMultiple) {\n      return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n        var _a;\n\n        return __spread(accumulatedAppointments, [_assign(_assign({}, currentAppointment), (_a = {}, _a[resourceField] = currentAppointment.dataItem[resourceField], _a))]);\n      }, []);\n    }\n\n    return acc.reduce(function (accumulatedAppointments, currentAppointment) {\n      return __spread(accumulatedAppointments, currentAppointment.dataItem[resourceField].map(function (resourceValue) {\n        var _a;\n\n        return _assign(_assign({}, currentAppointment), (_a = {}, _a[resourceField] = resourceValue, _a));\n      }));\n    }, []);\n  }, [appointment]);\n};\n\nvar getGroupingInfoFromGroups = function getGroupingInfoFromGroups(groups, groupIndex) {\n  var previousIndex = groupIndex;\n  return groups.reduceRight(function (acc, currentGroups, currentIndex) {\n    if (currentIndex === groups.length - 1) return acc;\n    var previousResourceLength = groups[currentIndex + 1].length / currentGroups.length;\n    var currentGroupingInstance = currentGroups[Math.floor(previousIndex / previousResourceLength)];\n    previousIndex = currentIndex;\n    return __spread(acc, [currentGroupingInstance]);\n  }, [groups[groups.length - 1][groupIndex]]);\n};\n\nvar allDayPredicate = function allDayPredicate(appointment) {\n  return appointment.end.diff(appointment.start, 'hours') > 23 || !!appointment.allDay;\n};\n\nvar getAllDayCellIndexByAppointmentData = function getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) {\n  var currentDate = moment(date);\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupCount = viewMetaData.groupCount;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getAllDayHorizontallyGroupedColumnIndex(viewCellsData, currentDate, appointment) : getAllDayVerticallyGroupedColumnIndex(viewCellsData, currentDate);\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 0 : getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount);\n  var cellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    cellIndex -= 1;\n  }\n\n  return cellIndex;\n};\n\nvar getAllDayVerticallyGroupedColumnIndex = function getAllDayVerticallyGroupedColumnIndex(viewCellsData, date) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date');\n  });\n};\n\nvar getAllDayHorizontallyGroupedColumnIndex = function getAllDayHorizontallyGroupedColumnIndex(viewCellsData, date, appointment) {\n  return viewCellsData[0].findIndex(function (timeCell) {\n    return date.isSame(timeCell.startDate, 'date') && checkCellGroupingInfo(timeCell, appointment);\n  });\n};\n\nvar getAllDayVerticallyGroupedRowIndex = function getAllDayVerticallyGroupedRowIndex(viewCellsData, appointment, groupCount) {\n  var index = viewCellsData.findIndex(function (viewCellsDataRow) {\n    return checkCellGroupingInfo(viewCellsDataRow[0], appointment);\n  });\n  return index * groupCount / viewCellsData.length;\n};\n\nvar sliceAppointmentsByBoundaries = function sliceAppointmentsByBoundaries(appointment, left, right, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start.clone();\n  var endDate = appointment.end.clone();\n  var nextStart = startDate.clone();\n  var nextEnd = endDate.clone();\n\n  if (startDate.isBefore(left)) {\n    nextStart = moment(left);\n    nextStart.startOf('day');\n  }\n\n  if (endDate.isAfter(right)) {\n    nextEnd = moment(right);\n    nextEnd.endOf('day');\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === startDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) !== -1 && nextStart.isSameOrBefore(endDate, 'day')) {\n      nextStart.add(1, 'days').startOf('day');\n    }\n  }\n\n  if (excludedDays.findIndex(function (day) {\n    return day === endDate.day();\n  }) !== -1) {\n    while (excludedDays.findIndex(function (day) {\n      return day === nextEnd.day();\n    }) !== -1 && nextStart.isSameOrAfter(startDate, 'day')) {\n      nextEnd.add(-1, 'days').endOf('day');\n    }\n  }\n\n  return [_assign(_assign({}, appointment), {\n    start: nextStart,\n    end: nextEnd\n  })];\n};\n\nvar sliceAppointmentsByDays = function sliceAppointmentsByDays(appointment, excludedDays) {\n  if (excludedDays === void 0) {\n    excludedDays = [];\n  }\n\n  var startDate = appointment.start;\n  var endDate = appointment.end;\n  var nextStart = startDate.clone();\n  var appointments = [];\n\n  while (nextStart.isBefore(endDate)) {\n    if (excludedDays.findIndex(function (day) {\n      return day === nextStart.day();\n    }) === -1) {\n      appointments.push(_assign(_assign({}, appointment), {\n        start: nextStart,\n        end: moment(nextStart).endOf('day')\n      }));\n    }\n\n    nextStart = moment(nextStart).add(1, 'day');\n  }\n\n  return appointments;\n};\n\nvar allDayCellsData = function allDayCellsData(viewCellsData, groups, groupOrientation) {\n  return groupOrientation !== VERTICAL_GROUP_ORIENTATION || !groups ? allDayCells(viewCellsData) : allDayCellsFromViewCellsAndGroups(viewCellsData, groups);\n};\n\nvar allDayCellsFromViewCellsAndGroups = function allDayCellsFromViewCellsAndGroups(viewCellsData, groups) {\n  return groups[groups.length - 1].reduce(function (acc, group, index) {\n    var groupingInfo = getGroupingInfoFromGroups(groups, index);\n    return __spread(acc, viewCellsData[0].map(function (_a) {\n      var startDate = _a.startDate;\n      return {\n        startDate: moment(startDate).startOf('day').toDate(),\n        endDate: moment(startDate).add(1, 'day').startOf('day').toDate(),\n        groupingInfo: groupingInfo\n      };\n    }));\n  }, []);\n};\n\nvar DEFAULT_RULE_OBJECT = {\n  interval: 1\n};\nvar DAYS_OF_WEEK = {\n  MONDAY: 0,\n  TUESDAY: 1,\n  WEDNESDAY: 2,\n  THURSDAY: 3,\n  FRIDAY: 4,\n  SATURDAY: 5,\n  SUNDAY: 6\n};\nvar DAYS_IN_WEEK = 7;\nvar DAYS_OF_WEEK_ARRAY = [DAYS_OF_WEEK.SUNDAY, DAYS_OF_WEEK.MONDAY, DAYS_OF_WEEK.TUESDAY, DAYS_OF_WEEK.WEDNESDAY, DAYS_OF_WEEK.THURSDAY, DAYS_OF_WEEK.FRIDAY, DAYS_OF_WEEK.SATURDAY];\nvar MONTHS = {\n  JANUARY: 1,\n  FEBRUARY: 2,\n  MARCH: 3,\n  APRIL: 4,\n  MAY: 5,\n  JUNE: 6,\n  JULY: 7,\n  AUGUST: 8,\n  SEPTEMBER: 9,\n  OCTOBER: 10,\n  NOVEMBER: 11,\n  DECEMBER: 12\n};\nvar RRULE_REPEAT_TYPES = {\n  YEARLY: RRule.YEARLY,\n  MONTHLY: RRule.MONTHLY,\n  WEEKLY: RRule.WEEKLY,\n  DAILY: RRule.DAILY,\n  HOURLY: RRule.HOURLY,\n  MINUTELY: RRule.MINUTELY\n};\nvar REPEAT_TYPES = {\n  DAILY: 'daily',\n  WEEKLY: 'weekly',\n  MONTHLY: 'monthly',\n  YEARLY: 'yearly',\n  NEVER: 'never'\n};\nvar REPEAT_TYPES_ARRAY = [REPEAT_TYPES.DAILY, REPEAT_TYPES.WEEKLY, REPEAT_TYPES.MONTHLY, REPEAT_TYPES.YEARLY];\nvar WEEK_NUMBER_LABELS = ['firstLabel', 'secondLabel', 'thirdLabel', 'fourthLabel', 'lastLabel'];\nvar END_REPEAT_RADIO_GROUP = 'endRepeat';\nvar MONTHLY_RADIO_GROUP = 'monthlyRadioGroup';\nvar YEARLY_RADIO_GROUP = 'yearlyRadioGroup';\nvar TITLE_TEXT_EDITOR = 'titleTextEditor';\nvar MULTILINE_TEXT_EDITOR = 'multilineTextEditor';\nvar ORDINARY_TEXT_EDITOR = 'ordinaryTextEditor';\nvar NUMBER_EDITOR = 'numberEditor';\nvar TITLE = 'title';\nvar ORDINARY_LABEL = 'ordinaryLabel';\nvar SAVE_BUTTON = 'saveButton';\nvar DELETE_BUTTON = 'deleteButton';\nvar CANCEL_BUTTON = 'cancelButton';\nvar OUTLINED_SELECT = 'outlinedSelect';\nvar STANDARD_SELECT = 'standardSelect';\nvar SUNDAY_DATE = new Date(2019, 7, 11);\nvar MONDAY_DATE = new Date(2019, 7, 12);\nvar TUESDAY_DATE = new Date(2019, 7, 13);\nvar WEDNESDAY_DATE = new Date(2019, 7, 14);\nvar THURSDAY_DATE = new Date(2019, 7, 15);\nvar FRIDAY_DATE = new Date(2019, 7, 16);\nvar SATURDAY_DATE = new Date(2019, 7, 17);\nvar DAYS_OF_WEEK_DATES = [SUNDAY_DATE, MONDAY_DATE, TUESDAY_DATE, WEDNESDAY_DATE, THURSDAY_DATE, FRIDAY_DATE, SATURDAY_DATE];\nvar JANUARY_DATE = new Date(2019, 0, 1);\nvar FEBRUARY_DATE = new Date(2019, 1, 1);\nvar MARCH_DATE = new Date(2019, 2, 1);\nvar APRIL_DATE = new Date(2019, 3, 1);\nvar MAY_DATE = new Date(2019, 4, 1);\nvar JUNE_DATE = new Date(2019, 5, 1);\nvar JULY_DATE = new Date(2019, 6, 1);\nvar AUGUST_DATE = new Date(2019, 7, 1);\nvar SEPTEMBER_DATE = new Date(2019, 8, 1);\nvar OCTOBER_DATE = new Date(2019, 9, 1);\nvar NOVEMBER_DATE = new Date(2019, 10, 1);\nvar DECEMBER_DATE = new Date(2019, 11, 1);\nvar MONTHS_DATES = [JANUARY_DATE, FEBRUARY_DATE, MARCH_DATE, APRIL_DATE, MAY_DATE, JUNE_DATE, JULY_DATE, AUGUST_DATE, SEPTEMBER_DATE, OCTOBER_DATE, NOVEMBER_DATE, DECEMBER_DATE];\nvar FIRST_WEEK = 0;\nvar SECOND_WEEK = 1;\nvar THIRD_WEEK = 2;\nvar FOURTH_WEEK = 3;\nvar LAST_WEEK = 4;\nvar BASIC_YEALY_COUNT = 5;\nvar BASIC_MONTHLY_COUNT = 12;\nvar BASIC_WEEKLY_COUNT = 13;\nvar BASIC_DAILY_COUNT = 30;\n\nvar sliceAppointmentByWeek = function sliceAppointmentByWeek(timeBounds, appointment, step) {\n  var left = timeBounds.left,\n      right = timeBounds.right;\n  var pieces = [];\n\n  var start = appointment.start,\n      end = appointment.end,\n      restFields = __rest(appointment, [\"start\", \"end\"]);\n\n  var apptStart = start;\n  var apptEnd = end;\n  if (apptStart.isBefore(left)) apptStart = left.clone();\n  if (apptEnd.isAfter(right)) apptEnd = right.clone();\n  var pieceFrom = apptStart.clone();\n  var pieceTo = apptStart.clone();\n  var i = 0;\n\n  while (pieceTo.isBefore(apptEnd)) {\n    var currentRightBound = left.clone().add(step * i, 'days').subtract(1, 'second');\n\n    if (currentRightBound.isAfter(apptStart)) {\n      pieceTo = apptStart.clone().add(step * i, 'days');\n\n      if (pieceTo.isAfter(currentRightBound)) {\n        pieceTo = currentRightBound.clone();\n      }\n\n      if (pieceTo.isAfter(apptEnd)) {\n        pieceTo = apptEnd.clone();\n      }\n\n      if (!pieceFrom.isSameOrAfter(pieceTo)) {\n        pieces.push(_assign({\n          start: pieceFrom,\n          end: pieceTo\n        }, restFields));\n        pieceFrom = pieceTo.clone().add(1, 'second');\n      }\n    }\n\n    i += 1;\n  }\n\n  return pieces;\n};\n\nvar getMonthCellIndexByAppointmentData = function getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) {\n  if (takePrev === void 0) {\n    takePrev = false;\n  }\n\n  var groupOrientation = viewMetaData.groupOrientation,\n      groupedByDate = viewMetaData.groupedByDate,\n      groupCount = viewMetaData.groupCount;\n  var startViewDate = moment(viewCellsData[0][0].startDate);\n  var currentDate = moment(date);\n  var dayNumber = currentDate.diff(startViewDate, 'days');\n\n  if (takePrev && currentDate.format() === currentDate.startOf('day').format()) {\n    dayNumber -= 1;\n  }\n\n  var weekNumber = Math.floor(dayNumber / DAYS_IN_WEEK);\n  var dayOfWeek = dayNumber % DAYS_IN_WEEK;\n  var columnIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupedByDate) : dayOfWeek;\n  var rowIndex = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? weekNumber : getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount);\n  var totalCellIndex = rowIndex * viewCellsData[0].length + columnIndex;\n  return totalCellIndex;\n};\n\nvar getMonthHorizontallyGroupedColumnIndex = function getMonthHorizontallyGroupedColumnIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount, groupByDate) {\n  var columnIndex = -1;\n  var currentColumnIndex = groupByDate ? dayOfWeek * groupCount : dayOfWeek;\n  var cellsInGroupRow = groupByDate ? 1 : DAYS_IN_WEEK;\n\n  while (columnIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[weekNumber][currentColumnIndex], appointment);\n\n    if (isCorrectCell) {\n      columnIndex = currentColumnIndex;\n    }\n\n    currentColumnIndex += cellsInGroupRow;\n  }\n\n  return columnIndex;\n};\n\nvar getMonthVerticallyGroupedRowIndex = function getMonthVerticallyGroupedRowIndex(viewCellsData, appointment, weekNumber, dayOfWeek, groupCount) {\n  var rowsInOneGroup = viewCellsData.length / groupCount;\n  var rowIndex = -1;\n  var currentRowIndex = weekNumber;\n\n  while (rowIndex === -1) {\n    var isCorrectCell = checkCellGroupingInfo(viewCellsData[currentRowIndex][dayOfWeek], appointment);\n\n    if (isCorrectCell) {\n      rowIndex = currentRowIndex;\n    }\n\n    currentRowIndex += rowsInOneGroup;\n  }\n\n  return rowIndex;\n};\n\nvar TOP_CELL_OFFSET = 0.32;\nvar CELL_BOUND_OFFSET_PX = 1;\n\nvar getCellRect$1 = function getCellRect$1(date, appointment, viewCellsData, viewMetaData, cellElementsMeta, takePrev, multiline) {\n  var cellIndex = multiline ? getMonthCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev) : getAllDayCellIndexByAppointmentData(viewCellsData, viewMetaData, date, appointment, takePrev);\n\n  var _a = cellElementsMeta.getCellRects[cellIndex](),\n      top = _a.top,\n      left = _a.left,\n      width = _a.width,\n      height = _a.height;\n\n  var parentRect = cellElementsMeta.parentRect();\n  return {\n    top: top,\n    left: left,\n    width: width,\n    height: height,\n    parentRect: parentRect\n  };\n};\n\nvar getHorizontalRectByAppointmentData = function getHorizontalRectByAppointmentData(appointment, viewMetaData, _a) {\n  var multiline = _a.multiline,\n      viewCellsData = _a.viewCellsData,\n      cellElementsMeta = _a.cellElementsMeta;\n  var firstCellRect = getCellRect$1(appointment.start.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, false, multiline);\n  var lastCellRect = getCellRect$1(appointment.end.toDate(), appointment, viewCellsData, viewMetaData, cellElementsMeta, true, multiline);\n  var top = firstCellRect.top + firstCellRect.height * TOP_CELL_OFFSET;\n  var height = firstCellRect.height - firstCellRect.height * TOP_CELL_OFFSET;\n  return {\n    top: top - firstCellRect.parentRect.top,\n    left: firstCellRect.left - firstCellRect.parentRect.left + CELL_BOUND_OFFSET_PX,\n    width: lastCellRect.left - firstCellRect.left + firstCellRect.width - CELL_BOUND_OFFSET_PX,\n    height: height,\n    parentWidth: firstCellRect.parentRect.width\n  };\n};\n\nvar DAY_COUNT = 7;\nvar MONTH_LENGTH = 31;\n\nvar monthCellsData = function monthCellsData(currentDate, firstDayOfWeek, intervalCount, today) {\n  if (intervalCount === void 0) {\n    intervalCount = 1;\n  }\n\n  var targetDate = moment(currentDate);\n  var currentMonths = [targetDate.month()];\n\n  while (currentMonths.length < intervalCount) {\n    currentMonths.push(targetDate.add(1, 'months').month());\n  }\n\n  var firstMonthDate = moment(currentDate).date(1);\n  var firstMonthDay = firstMonthDate.day() - firstDayOfWeek;\n  var prevMonthDayCount = firstMonthDate.day(firstMonthDay).day() || DAY_COUNT;\n  var prevMonth = moment(currentDate).subtract(1, 'months');\n  var prevMonthStartDay = prevMonth.daysInMonth() - (prevMonthDayCount - 1);\n  var from = moment().year(prevMonth.year()).month(prevMonth.month()).date(prevMonthStartDay).startOf('day');\n  var result = [];\n\n  while (result.length < Math.trunc(MONTH_LENGTH * intervalCount / DAY_COUNT) + 2) {\n    var week = [];\n\n    while (week.length < DAY_COUNT) {\n      week.push({\n        startDate: from.toDate(),\n        endDate: from.clone().add(1, 'day').toDate(),\n        otherMonth: currentMonths.findIndex(function (month) {\n          return month === from.month();\n        }) === -1,\n        today: today ? moment(today).isSame(from, 'date') : false\n      });\n      from.add(1, 'day');\n    }\n\n    result.push(week);\n  }\n\n  return result;\n};\n\nvar calculateMonthDateIntervals = function calculateMonthDateIntervals(appointments, leftBound, rightBound) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, [], false));\n  }, []).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentByWeek({\n      left: moment(leftBound),\n      right: moment(rightBound)\n    }, appointment, DAY_COUNT));\n  }, [])];\n};\n\nvar calculateAllDayDateIntervals = function calculateAllDayDateIntervals(appointments, leftBound, rightBound, excludedDays) {\n  return [appointments.map(function (_a) {\n    var start = _a.start,\n        end = _a.end,\n        restArgs = __rest(_a, [\"start\", \"end\"]);\n\n    return _assign({\n      start: moment(start),\n      end: moment(end)\n    }, restArgs);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, filterByViewBoundaries(appointment, leftBound, rightBound, excludedDays, false));\n  }, []).filter(function (appointment) {\n    return allDayPredicate(appointment);\n  }).reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByBoundaries(appointment, leftBound, rightBound, excludedDays));\n  }, [])];\n};\n\nvar filterResourcesByGrouping = function filterResourcesByGrouping(resources, grouping) {\n  return resources.filter(function (resource) {\n    return grouping.find(function (resourceId) {\n      return resource.fieldName === resourceId.resourceName;\n    });\n  });\n};\n\nvar sortFilteredResources = function sortFilteredResources(resources, grouping) {\n  return grouping.map(function (_a) {\n    var resourceName = _a.resourceName;\n    return resources.find(function (resource) {\n      return resource.fieldName === resourceName;\n    });\n  });\n};\n\nvar getGroupsFromResources = function getGroupsFromResources(sortedAndFilteredResources) {\n  return sortedAndFilteredResources.reduce(function (acc, resource, index) {\n    if (index === 0) {\n      return [resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      })];\n    }\n\n    return __spread(acc, [acc[index - 1].reduce(function (currentResourceNames) {\n      return __spread(currentResourceNames, resource.instances.map(function (instance) {\n        return getGroupFromResourceInstance(instance);\n      }));\n    }, [])]);\n  }, []);\n};\n\nvar expandViewCellsDataWithGroups = function expandViewCellsDataWithGroups(viewCellsData, groups, sortedResources, groupByDate, groupOrientation) {\n  if (groups.length === 0) return viewCellsData;\n\n  if (groupByDate) {\n    return expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources);\n  }\n\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources);\n  }\n\n  return expandVerticallyGroupedCells(viewCellsData, groups, sortedResources);\n};\n\nvar expandCellsWithGroupedByDateData = function expandCellsWithGroupedByDateData(viewCellsData, groups, sortedResources) {\n  return viewCellsData.map(function (cellsRow) {\n    return cellsRow.reduce(function (acc, viewCell) {\n      var groupedCells = groups[groups.length - 1].map(function (group, index) {\n        return addGroupInfoToCell(group, groups, sortedResources, viewCell, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n      groupedCells[groupedCells.length - 1] = _assign(_assign({}, groupedCells[groupedCells.length - 1]), {\n        endOfGroup: true\n      });\n      return __spread(acc, groupedCells);\n    }, []);\n  });\n};\n\nvar expandHorizontallyGroupedCells = function expandHorizontallyGroupedCells(viewCellsData, groups, sortedResources) {\n  return groups[groups.length - 1].reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, false, HORIZONTAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return acc.map(function (item, id) {\n      return __spread(item, addGroupInfoToCells(group, groups, sortedResources, viewCellsData[id], index, false, HORIZONTAL_GROUP_ORIENTATION));\n    });\n  }, [[]]);\n};\n\nvar expandVerticallyGroupedCells = function expandVerticallyGroupedCells(viewCellsData, groups, sortedResources) {\n  return groups[groups.length - 1].reduce(function (acc, group, index) {\n    if (index === 0) {\n      return viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n        return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n      });\n    }\n\n    return __spread(acc, viewCellsData.map(function (viewCellsRow, viewRowIndex) {\n      return addGroupInfoToCells(group, groups, sortedResources, viewCellsRow, index, viewRowIndex === viewCellsData.length - 1, VERTICAL_GROUP_ORIENTATION);\n    }));\n  }, [[]]);\n};\n\nvar updateGroupingWithMainResource = function updateGroupingWithMainResource(grouping, resources) {\n  return grouping || [{\n    resourceName: resources.find(function (resource) {\n      return resource.isMain;\n    }).fieldName\n  }];\n};\n\nvar expandGroups = function expandGroups(appointments, grouping, resources, groups, excludedDays, sliceByDay) {\n  if (sliceByDay === void 0) {\n    sliceByDay = false;\n  }\n\n  var slicedAppointments = sliceByDay ? appointments[0].reduce(function (acc, appointment) {\n    return __spread(acc, sliceAppointmentsByDays(appointment, excludedDays));\n  }, []) : appointments[0];\n  var expandedAppointments = slicedAppointments.reduce(function (acc, appointment) {\n    return __spread(acc, expandGroupedAppointment(appointment, grouping, resources));\n  }, []);\n  return groupAppointments(expandedAppointments, resources, groups);\n};\n\nvar allDayRects = function allDayRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateAllDayDateIntervals(appointments, startViewDate, endViewDate, excludedDays);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta,\n    excludedDays: excludedDays\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? groups[groups.length - 1].length : 1\n  });\n};\n\nvar verticalTimeTableRects = function verticalTimeTableRects(appointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDuration, cellElementsMeta, grouping, resources, groups, groupOrientation, groupByDate) {\n  var intervals = calculateWeekDateIntervals(appointments, startViewDate, endViewDate, excludedDays, cellDuration);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, excludedDays, false);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: VERTICAL_TYPE,\n    multiline: false\n  }, groupedIntervals, getVerticalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellDuration: cellDuration,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: groupByDate,\n    groupCount: groups ? groups[groups.length - 1].length : 1\n  });\n};\n\nvar horizontalTimeTableRects = function horizontalTimeTableRects(appointments, startViewDate, endViewDate, viewCellsData, cellElementsMeta, grouping, resources, groups, groupOrientation, sliceAppointments) {\n  var intervals = calculateMonthDateIntervals(appointments, startViewDate, endViewDate);\n  var groupedIntervals = expandGroups(intervals, grouping, resources, groups, [], sliceAppointments);\n  return calculateRectByDateAndGroupIntervals({\n    growDirection: HORIZONTAL_TYPE,\n    multiline: true\n  }, groupedIntervals, getHorizontalRectByAppointmentData, {\n    startViewDate: startViewDate,\n    endViewDate: endViewDate,\n    viewCellsData: viewCellsData,\n    cellElementsMeta: cellElementsMeta\n  }, {\n    groupOrientation: groupOrientation,\n    groupedByDate: sliceAppointments,\n    groupCount: groups ? groups[groups.length - 1].length : 1\n  });\n};\n\nvar dateTimeFormatInstance = function dateTimeFormatInstance(locale, formatOptions) {\n  return new Intl.DateTimeFormat(locale, formatOptions);\n};\n\nvar appointments = function appointments(data) {\n  return data.map(function (appointment) {\n    return _assign(_assign(_assign(_assign({\n      dataItem: appointment,\n      start: appointment.startDate\n    }, appointment.endDate !== undefined ? {\n      end: appointment.endDate\n    } : {\n      end: appointment.startDate,\n      dataItem: _assign(_assign({}, appointment), {\n        endDate: appointment.startDate\n      })\n    }), appointment.allDay !== undefined && {\n      allDay: appointment.allDay\n    }), appointment.rRule !== undefined && {\n      rRule: appointment.rRule\n    }), appointment.exDate !== undefined && {\n      exDate: appointment.exDate\n    });\n  });\n};\n\nvar formatDateTimeGetter = function formatDateTimeGetter(locale) {\n  var cache = new Map(); // any -> type\n\n  var formatter = function formatter(nextDate, nextOptions) {\n    if (nextDate === undefined) return '';\n    var date = new Date(nextDate);\n    var formatInstance = cache.get(nextOptions);\n\n    if (!formatInstance) {\n      formatInstance = dateTimeFormatInstance(locale, nextOptions);\n      cache.set(nextOptions, formatInstance);\n    }\n\n    return formatInstance.format(date);\n  };\n\n  return formatter;\n};\n\nvar getCellKey = function getCellKey(groups, groupIndex, rowNumber) {\n  var currentIndex = groupIndex;\n  return groups.reduceRight(function (acc, groupRow, rowIndex) {\n    if (rowNumber < rowIndex) return acc;\n    var currentKey = groupRow[currentIndex].id;\n\n    if (rowIndex > 0) {\n      var currentRowLength = groups[rowIndex].length / groups[rowIndex - 1].length;\n      currentIndex = Math.floor(currentIndex / currentRowLength);\n    }\n\n    return acc + currentKey;\n  }, '');\n};\n\nvar getRowFromGroups = function getRowFromGroups(width, groupRow, cellStyle, groups, rowIndex) {\n  var row = [];\n  var currentRowLength = groupRow.length;\n  var standardWidth = width / groups[groups.length - 1].length;\n  var colSpan = groups[groups.length - 1].length / currentRowLength;\n\n  var _loop_1 = function _loop_1(i) {\n    row = __spread(row, groupRow.reduce(function (acc, group, index) {\n      return __spread(acc, [{\n        group: group,\n        colSpan: colSpan,\n        key: getCellKey(groups, index, rowIndex) + i,\n        left: cellStyle.left,\n        endOfGroup: index === currentRowLength - 1\n      }]);\n    }, []));\n  };\n\n  for (var i = 0; i < standardWidth; i += 1) {\n    _loop_1(i);\n  }\n\n  return row;\n};\n\nvar getVerticalRowFromGroups = function getVerticalRowFromGroups(groups, groupIndex, groupingPanelRowSpan, timeTableCellHeight) {\n  return groups.reduce(function (acc, groupColumn, columnIndex) {\n    var groupSpan = groups[groups.length - 1].length / groupColumn.length;\n    var cellIndex = groupIndex / groupSpan;\n    return groupIndex % groupSpan !== 0 ? acc : __spread(acc, [{\n      group: groupColumn[cellIndex],\n      rowSpan: groupSpan,\n      height: groupingPanelRowSpan * groupSpan * timeTableCellHeight / groups[groups.length - 1].length,\n      key: getCellKey(groups, cellIndex, columnIndex)\n    }]);\n  }, []);\n};\n\nvar getLabelsForSingleGroup = function getLabelsForSingleGroup(groups, cellsData, groupIndex, groupHeight) {\n  var currentGroupIndex = groupIndex * groupHeight;\n  var nextGroupIndex = currentGroupIndex + groupHeight;\n  return cellsData.slice(currentGroupIndex, nextGroupIndex - 1).reduce(function (acc, days) {\n    return __spread(acc, [{\n      startDate: days[0].startDate,\n      endDate: days[0].endDate,\n      key: days[0].endDate + getCellKey(groups, groupIndex, groups.length - 1),\n      groupingInfo: days[0].groupingInfo\n    }]);\n  }, []);\n};\n\nvar getLabelsForAllGroups = function getLabelsForAllGroups(cellsData, groups, groupOrientation) {\n  if (groupOrientation === HORIZONTAL_GROUP_ORIENTATION) {\n    return [cellsData.map(function (cellsRow) {\n      return {\n        startDate: cellsRow[0].startDate,\n        endDate: cellsRow[0].endDate,\n        groupingInfo: cellsRow[0].groupingInfo,\n        key: cellsRow[0].endDate\n      };\n    })];\n  }\n\n  var groupCount = groups[groups.length - 1].length;\n  var singleGroupHeight = cellsData.length / groupCount;\n  return groups[groups.length - 1].reduce(function (acc, group, groupIndex) {\n    return __spread(acc, [getLabelsForSingleGroup(groups, cellsData, groupIndex, singleGroupHeight)]);\n  }, []);\n};\n\nvar changeCurrentDate = function changeCurrentDate(currentDate, _a) {\n  var nextDate = _a.nextDate,\n      step = _a.step,\n      amount = _a.amount,\n      direction = _a.direction;\n  return nextDate || moment(currentDate)[direction === 'back' ? 'subtract' : 'add'](amount, step).toDate() || moment().subtract(amount, step);\n};\n\nvar setCurrentViewName = function setCurrentViewName(currentViewName, nextViewName) {\n  return nextViewName;\n};\n\nvar setAppointmentMeta = function setAppointmentMeta(prevAppointmentMeta, _a) {\n  var target = _a.target,\n      data = _a.data;\n  return {\n    target: target,\n    data: data\n  };\n};\n\nvar OPEN_COMMAND_BUTTON = 'open';\nvar CLOSE_COMMAND_BUTTON = 'close';\nvar DELETE_COMMAND_BUTTON = 'delete';\nvar CANCEL_COMMAND_BUTTON = 'cancel';\nvar COMMIT_COMMAND_BUTTON = 'commit';\n\nvar setAppointmentData = function setAppointmentData(prevAppointmentData, _a) {\n  var appointmentData = _a.appointmentData;\n  return appointmentData;\n};\n\nvar getWeekNumberLabels = function getWeekNumberLabels(getMessage) {\n  return WEEK_NUMBER_LABELS.map(function (weekNumberLabel, index) {\n    return {\n      text: getMessage(weekNumberLabel),\n      id: index\n    };\n  });\n};\n\nvar getDaysOfWeek = function getDaysOfWeek(formatDate, firstDayOfWeek) {\n  var daysOfWeekArray = getDaysOfWeekArray(firstDayOfWeek);\n  var daysOfWeekDates = getDaysOfWeekDates(firstDayOfWeek);\n  return daysOfWeekDates.map(function (day, index) {\n    return {\n      text: getDayOfWeek(day, formatDate),\n      id: index + 1 < DAYS_IN_WEEK ? daysOfWeekArray[index + 1] : daysOfWeekArray[0]\n    };\n  });\n};\n\nvar getMonths = function getMonths(formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonth(month, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthsWithOf = function getMonthsWithOf(getMessage, formatDate) {\n  return MONTHS_DATES.map(function (month, index) {\n    return {\n      text: getMonthWithOf(month, getMessage, formatDate),\n      id: getMonthId(index)\n    };\n  });\n};\n\nvar getMonthWithOf = function getMonthWithOf(date, getMessage, formatDate) {\n  return getMessage('ofLabel') + formatDate(date, DAY_LONG_MONTH_OPTIONS).replace(/[\\d.,]/g, '').toString();\n};\n\nvar getMonth = function getMonth(date, formatDate) {\n  return formatDate(date, LONG_MONTH_OPTIONS);\n};\n\nvar getDayOfWeek = function getDayOfWeek(date, formatDate) {\n  return formatDate(date, LONG_WEEK_DAY_OPTIONS);\n};\n\nvar getMonthId = function getMonthId(index) {\n  return index + 1;\n};\n\nvar getAvailableRecurrenceOptions = function getAvailableRecurrenceOptions(getMessage) {\n  return REPEAT_TYPES_ARRAY.map(function (type) {\n    return {\n      text: getMessage(type),\n      id: type\n    };\n  });\n};\n\nvar getCountDependingOnRecurrenceType = function getCountDependingOnRecurrenceType(frequency) {\n  var count;\n\n  switch (frequency) {\n    case RRULE_REPEAT_TYPES.YEARLY:\n      count = BASIC_YEALY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.MONTHLY:\n      count = BASIC_MONTHLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.WEEKLY:\n      count = BASIC_WEEKLY_COUNT;\n      break;\n\n    case RRULE_REPEAT_TYPES.DAILY:\n      count = BASIC_DAILY_COUNT;\n      break;\n  }\n\n  return count;\n};\n\nvar checkIsNaturalNumber = function checkIsNaturalNumber(number) {\n  return number > 0 && number <= Number.MAX_SAFE_INTEGER;\n};\n\nvar callActionIfExists = function callActionIfExists(action, payload) {\n  if (action) {\n    action(payload);\n  }\n};\n\nvar isAllDayCell = function isAllDayCell(startDate, endDate) {\n  return moment(endDate).diff(moment(startDate), 'days') >= 1;\n};\n\nvar changeRecurrenceFrequency = function changeRecurrenceFrequency(rule, freq, startDate) {\n  if (!rule) {\n    if (freq === RRULE_REPEAT_TYPES.MONTHLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n      return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n        freq: freq,\n        bymonthday: [startDate.getDate()],\n        bymonth: startDate.getMonth() + 1,\n        count: getCountDependingOnRecurrenceType(freq)\n      })).toString();\n    }\n\n    return new RRule(_assign(_assign({}, DEFAULT_RULE_OBJECT), {\n      freq: freq,\n      count: getCountDependingOnRecurrenceType(freq)\n    })).toString();\n  }\n\n  var options = RRule.parseString(rule);\n  if (options.freq === freq) return rule;\n  options.freq = freq;\n  options.count = getCountDependingOnRecurrenceType(freq);\n\n  if (freq === RRULE_REPEAT_TYPES.MONTHLY || freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonthday = startDate.getDate();\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.YEARLY) {\n    options.bymonth = startDate.getMonth() + 1;\n  }\n\n  if (freq === RRULE_REPEAT_TYPES.DAILY || freq === RRULE_REPEAT_TYPES.WEEKLY) {\n    options.bymonthday = undefined;\n  }\n\n  options.byweekday = undefined;\n  var nextRule = new RRule(options);\n  return nextRule.toString();\n};\n\nvar getRecurrenceOptions = function getRecurrenceOptions(rule) {\n  if (!rule) return null;\n  var options = RRule.parseString(rule);\n\n  if (options.byweekday) {\n    var byweekday = options.byweekday.map(function (weekDay) {\n      return weekDay.weekday;\n    });\n    options.byweekday = byweekday;\n  }\n\n  return options;\n};\n\nvar changeRecurrenceOptions = function changeRecurrenceOptions(options) {\n  return options ? new RRule(_assign({}, options)).toString() : undefined;\n};\n\nvar handleStartDateChange = function handleStartDateChange(nextStartDay, options) {\n  if (nextStartDay <= 31) {\n    var nextOptions = _assign(_assign({}, options), {\n      bymonthday: nextStartDay\n    });\n\n    return changeRecurrenceOptions(nextOptions);\n  }\n\n  return changeRecurrenceOptions(options);\n};\n\nvar handleToDayOfWeekChange = function handleToDayOfWeekChange(weekNumber, dayOfWeek, options) {\n  var nextOptions = setByMonthDay(weekNumber, options);\n  nextOptions.byweekday = dayOfWeek > 0 ? dayOfWeek - 1 : 6;\n  return changeRecurrenceOptions(nextOptions);\n};\n\nvar handleWeekNumberChange = function handleWeekNumberChange(nextWeekNumber, options) {\n  return changeRecurrenceOptions(setByMonthDay(nextWeekNumber, options));\n};\n\nvar getRRuleFrequency = function getRRuleFrequency(repeatType) {\n  return RRULE_REPEAT_TYPES[repeatType.toUpperCase()];\n};\n\nvar getFrequencyString = function getFrequencyString(rRuleFrequency) {\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.DAILY) return REPEAT_TYPES.DAILY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.WEEKLY) return REPEAT_TYPES.WEEKLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.MONTHLY) return REPEAT_TYPES.MONTHLY;\n  if (rRuleFrequency === RRULE_REPEAT_TYPES.YEARLY) return REPEAT_TYPES.YEARLY;\n  return REPEAT_TYPES.NEVER;\n};\n\nvar setByMonthDay = function setByMonthDay(nextWeekNumber, options) {\n  if (nextWeekNumber < 4) {\n    return _assign(_assign({}, options), {\n      bymonthday: [nextWeekNumber * 7 + 1, nextWeekNumber * 7 + 2, nextWeekNumber * 7 + 3, nextWeekNumber * 7 + 4, nextWeekNumber * 7 + 5, nextWeekNumber * 7 + 6, nextWeekNumber * 7 + 7]\n    });\n  }\n\n  return _assign(_assign({}, options), {\n    bymonthday: [-1, -2, -3, -4, -5, -6, -7]\n  });\n};\n\nvar getRadioGroupDisplayData = function getRadioGroupDisplayData(recurrenceOptions, stateDayOfWeek, stateWeekNumber, stateDayNumber, firstOption, secondOption) {\n  var weekNumber = LAST_WEEK;\n\n  if (recurrenceOptions.bymonthday && !Array.isArray(recurrenceOptions.bymonthday)) {\n    return {\n      dayNumberTextField: recurrenceOptions.bymonthday,\n      weekNumber: stateWeekNumber,\n      dayOfWeek: stateDayOfWeek,\n      radioGroupValue: firstOption\n    };\n  }\n\n  if (!recurrenceOptions.byweekday) {\n    return {\n      dayOfWeek: stateDayOfWeek,\n      weekNumber: stateWeekNumber,\n      radioGroupValue: secondOption,\n      dayNumberTextField: stateDayNumber\n    };\n  }\n\n  var dayOfWeek = recurrenceOptions.byweekday[0] < 6 ? recurrenceOptions.byweekday[0] + 1 : 0;\n\n  if (recurrenceOptions.bymonthday && recurrenceOptions.bymonthday[0] > 0) {\n    weekNumber = Math.trunc(recurrenceOptions.bymonthday[0] / 7);\n  }\n\n  return {\n    dayOfWeek: dayOfWeek,\n    weekNumber: weekNumber,\n    radioGroupValue: secondOption,\n    dayNumberTextField: stateDayNumber\n  };\n};\n\nvar handleChangeFrequency = function handleChangeFrequency(repeatType, rRule, startDate, action) {\n  var rruleRepeatType = getRRuleFrequency(repeatType);\n  var nextRRule;\n\n  if (rruleRepeatType !== undefined) {\n    nextRRule = changeRecurrenceFrequency(rRule, rruleRepeatType, startDate);\n  }\n\n  action({\n    rRule: nextRRule\n  });\n};\n\nvar handleWeekDaysChange = function handleWeekDaysChange(options, weekDay) {\n  var byWeekDay = options.byweekday || [];\n  var index = byWeekDay.indexOf(weekDay);\n  var isAdded = !(index > -1);\n\n  if (isAdded) {\n    byWeekDay.push(weekDay);\n  } else if (index > -1) {\n    byWeekDay.splice(index, 1);\n  }\n\n  if (byWeekDay === 0) return _assign(_assign({}, options), {\n    byweekday: undefined\n  });\n  return _assign(_assign({}, options), {\n    byweekday: byWeekDay\n  });\n};\n\nvar getDaysOfWeekArray = function getDaysOfWeekArray(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek >= firstDayOfWeek - 1 && dayOfWeek < DAYS_IN_WEEK - 1;\n  });\n  var secondPart = DAYS_OF_WEEK_ARRAY.filter(function (dayOfWeek) {\n    return dayOfWeek < firstDayOfWeek - 1 || dayOfWeek >= DAYS_IN_WEEK - 1;\n  });\n  return firstDayOfWeek !== 0 ? __spread(firstPart, secondPart) : __spread(secondPart, firstPart);\n};\n\nvar getDaysOfWeekDates = function getDaysOfWeekDates(firstDayOfWeek) {\n  var firstPart = DAYS_OF_WEEK_DATES.slice(firstDayOfWeek, DAYS_OF_WEEK_DATES.length);\n  var secondPart = DAYS_OF_WEEK_DATES.slice(0, firstDayOfWeek);\n  return __spread(firstPart, secondPart);\n};\n\nvar checkMultipleResourceFields = function checkMultipleResourceFields(resourceFields, resources) {\n  return resources.reduce(function (acc, resource) {\n    var _a;\n\n    if (!resource.allowMultiple) {\n      return acc;\n    }\n\n    var fieldName = resource.fieldName;\n    var field = resourceFields[fieldName];\n    return _assign(_assign({}, acc), (_a = {}, _a[fieldName] = Array.isArray(field) ? field : [field], _a));\n  }, resourceFields);\n};\n\nvar addAppointment = function addAppointment(addedAppointmentData, _a) {\n  var appointmentData = (_a === void 0 ? {\n    appointmentData: {}\n  } : _a).appointmentData;\n  return appointmentData;\n};\n\nvar cancelAddedAppointment = function cancelAddedAppointment() {\n  return {};\n};\n\nvar startEditAppointment = function startEditAppointment(prevEditingAppointment, appointmentData) {\n  return appointmentData;\n};\n\nvar stopEditAppointment = function stopEditAppointment() {\n  return undefined;\n};\n\nvar changeAppointment = function changeAppointment(appointment, _a) {\n  var change = _a.change;\n  return _assign(_assign({}, appointment), change);\n};\n\nvar cancelChanges = function cancelChanges() {\n  return {};\n};\n\nvar changedAppointmentById = function changedAppointmentById(changes, appointmentId) {\n  var _a;\n\n  return _a = {}, _a[appointmentId] = changes, _a;\n};\n\nvar mergeNewChanges = function mergeNewChanges(appointmentData, changes) {\n  var appointment = _assign({}, appointmentData);\n\n  delete appointment.id;\n  delete appointment.rRule;\n  delete appointment.exDate;\n  delete appointment.parentData;\n  return _assign(_assign({}, appointment), changes);\n};\n\nvar reduceExDate = function reduceExDate(prevExDate, boundDate) {\n  if (prevExDate.length > 0) {\n    return prevExDate.split(',').reduce(function (acc, date) {\n      var momentDate = moment.utc(date);\n\n      if (momentDate.isBefore(boundDate)) {\n        return __spread(acc, [date]);\n      }\n\n      return acc;\n    }, []).join(',');\n  }\n\n  return undefined;\n};\n\nvar configureExDate = function configureExDate(exDate, date) {\n  var currentExDate = moment.utc(date).format('YYYYMMDDTHHmmss') + \"Z\";\n  return exDate ? exDate + \",\" + currentExDate : currentExDate;\n};\n\nvar configureDateSequence = function configureDateSequence(rRule, exDate, prevStartDate, nextStartDate) {\n  var rruleSet = getRRuleSetWithExDates(exDate);\n  var currentOptions = RRule.parseString(rRule);\n  var correctedOptions = currentOptions.until ? _assign(_assign({}, currentOptions), {\n    until: moment(getUTCDate(currentOptions.until)).toDate()\n  }) : currentOptions;\n  var prevStartDateUTC = moment(getUTCDate(prevStartDate)).toDate();\n  rruleSet.rrule(new RRule(_assign(_assign({}, correctedOptions), {\n    dtstart: prevStartDateUTC\n  })));\n\n  if (currentOptions.count || currentOptions.until) {\n    return rruleSet.all() // we shouldn't use `new Date(string)` because this function has different results in Safari\n    .map(function (nextDate) {\n      return moment(formatDateToString(nextDate)).toDate();\n    });\n  }\n\n  var leftBound = prevStartDateUTC;\n  var rightBound = moment(getUTCDate(nextStartDate)).toDate();\n  return rruleSet.between(leftBound, rightBound, true).map(function (nextDate) {\n    return moment(formatDateToString(nextDate)).toDate();\n  });\n};\n\nvar configureICalendarRules = function configureICalendarRules(rRule, options) {\n  var rruleSet = new RRuleSet();\n  rruleSet.rrule(new RRule(_assign(_assign({}, RRule.parseString(rRule)), options)));\n  return rruleSet.valueOf();\n};\n\nvar changeCurrentAndFollowing = function changeCurrentAndFollowing(appointmentData, changes, changeAllAction) {\n  var _a;\n\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      parentData = appointmentData.parentData,\n      _b = appointmentData.exDate,\n      prevExDate = _b === void 0 ? '' : _b,\n      id = appointmentData.id;\n\n  var _c = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _c.initialSequence,\n      currentChildIndex = _c.currentChildIndex;\n\n  if (currentChildIndex === 0) return changeAllAction(appointmentData, changes);\n  var changedRules = configureICalendarRules(rRule, {\n    dtstart: moment.utc(parentData.startDate).toDate(),\n    until: moment.utc(initialSequence[currentChildIndex - 1]).toDate(),\n    count: null\n  });\n  var nextExDate = reduceExDate(prevExDate, startDate);\n  return {\n    changed: (_a = {}, _a[id] = _assign({\n      rRule: changedRules[1].slice(6)\n    }, nextExDate && prevExDate !== nextExDate ? {\n      exDate: nextExDate\n    } : {}), _a)\n  };\n};\n\nvar getAppointmentSequenceData = function getAppointmentSequenceData(prevStartDate, startDate, exDate, rRule) {\n  var initialSequence = configureDateSequence(rRule, exDate, moment.utc(prevStartDate).toDate(), moment.utc(startDate).toDate());\n  var currentChildIndex = initialSequence.findIndex(function (date) {\n    return moment(date).isSame(startDate);\n  });\n  return {\n    initialSequence: initialSequence,\n    currentChildIndex: currentChildIndex\n  };\n};\n\nvar deleteCurrent = function deleteCurrent(appointmentData) {\n  var _a;\n\n  var currentSequence = configureDateSequence(appointmentData.rRule, appointmentData.exDate, moment.utc(appointmentData.parentData.startDate).toDate(), moment.utc(appointmentData.startDate).toDate());\n\n  if (currentSequence.length === 1) {\n    return deleteAll(appointmentData);\n  }\n\n  var nextExDate = configureExDate(appointmentData.exDate, appointmentData.startDate);\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: nextExDate\n    }, _a)\n  };\n};\n\nvar deleteAll = function deleteAll(appointmentData) {\n  return {\n    deleted: appointmentData.id\n  };\n};\n\nvar deleteCurrentAndFollowing = function deleteCurrentAndFollowing(appointmentData) {\n  return changeCurrentAndFollowing(appointmentData, {}, deleteAll);\n};\n\nvar editAll = function editAll(appointmentData, changes) {\n  var _a, _b;\n\n  var rRule = appointmentData.rRule,\n      id = appointmentData.id;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  if (changes.startDate && moment.utc(changes.startDate).isAfter(initialRule.options.until)) {\n    return {\n      changed: (_a = {}, _a[id] = _assign(_assign({}, changes), {\n        rRule: 'FREQ=DAILY;COUNT=1',\n        exDate: ''\n      }), _a)\n    };\n  }\n\n  return {\n    changed: (_b = {}, _b[appointmentData.id] = changes, _b)\n  };\n};\n\nvar editCurrent = function editCurrent(appointmentData, changes) {\n  var _a;\n\n  return {\n    changed: (_a = {}, _a[appointmentData.id] = {\n      exDate: configureExDate(appointmentData.exDate, appointmentData.startDate)\n    }, _a),\n    added: mergeNewChanges(appointmentData, changes)\n  };\n};\n\nvar editCurrentAndFollowing = function editCurrentAndFollowing(appointmentData, changes) {\n  var rRule = appointmentData.rRule,\n      startDate = appointmentData.startDate,\n      _a = appointmentData.exDate,\n      prevExDate = _a === void 0 ? '' : _a,\n      parentData = appointmentData.parentData;\n  var initialRule = new RRule(RRule.parseString(rRule));\n\n  var _b = getAppointmentSequenceData(parentData.startDate, moment.utc(startDate).toDate(), prevExDate, rRule),\n      initialSequence = _b.initialSequence,\n      currentChildIndex = _b.currentChildIndex;\n\n  if (currentChildIndex === 0) return editAll(appointmentData, changes);\n  var addedOptions = initialRule.options.count || initialRule.options.until ? {\n    count: initialSequence.length - currentChildIndex\n  } : {};\n  var addedRules = configureICalendarRules(appointmentData.rRule, _assign({\n    dtstart: moment.utc(startDate).toDate()\n  }, addedOptions));\n  var addedAppointment = moment.utc(changes.startDate).isAfter(initialRule.options.until) ? {\n    rRule: 'FREQ=DAILY;COUNT=1',\n    exDate: ''\n  } : {\n    rRule: addedRules[1].slice(6)\n  };\n  return {\n    changed: changeCurrentAndFollowing(appointmentData, changes, editAll).changed,\n    added: _assign(_assign({}, addedAppointment), mergeNewChanges(appointmentData, changes))\n  };\n};\n\nvar preCommitChanges = function preCommitChanges(changes, appointmentData, editType) {\n  if (changes === null) {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return deleteAll(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return deleteCurrent(appointmentData);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return deleteCurrentAndFollowing(appointmentData);\n        }\n    }\n  } else {\n    switch (editType) {\n      case RECURRENCE_EDIT_SCOPE.ALL:\n        {\n          return editAll(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT:\n        {\n          return editCurrent(appointmentData, changes);\n        }\n\n      case RECURRENCE_EDIT_SCOPE.CURRENT_AND_FOLLOWING:\n        {\n          return editCurrentAndFollowing(appointmentData, changes);\n        }\n    }\n  }\n\n  return {};\n};\n\nvar clamp = function clamp(value, min, max) {\n  return Math.max(Math.min(value, max), min);\n};\n\nvar calculateInsideOffset = function calculateInsideOffset(targetType, insidePart, cellDurationMinutes) {\n  return targetType === VERTICAL_TYPE ? insidePart * cellDurationMinutes * 60 / 2 : 0;\n};\n\nvar cellType = function cellType(data) {\n  return moment(data.startDate).isSame(data.endDate, 'day') ? VERTICAL_TYPE : HORIZONTAL_TYPE;\n};\n\nvar intervalDuration = function intervalDuration(data, type) {\n  return moment(data.endDate).diff(data.startDate, type);\n};\n\nvar cellIndex = function cellIndex(getCellRects, clientOffset) {\n  return getCellRects.findIndex(function (getCellRect) {\n    var _a = getCellRect(),\n        left = _a.left,\n        top = _a.top,\n        right = _a.right,\n        bottom = _a.bottom;\n\n    var isOver = clientOffset && clamp(clientOffset.x, left, right) === clientOffset.x && clamp(clientOffset.y, top, bottom) === clientOffset.y;\n    return isOver;\n  });\n};\n\nvar cellData = function cellData(timeTableIndex, allDayIndex, viewCellsData, groups, groupOrientation) {\n  if (allDayIndex !== -1) {\n    var allDayCellsData$1 = allDayCellsData(viewCellsData, groups, groupOrientation);\n    return allDayCellsData$1[allDayIndex];\n  }\n\n  var rowIndex = Math.floor(timeTableIndex / viewCellsData[0].length);\n  var columnIndex = timeTableIndex % viewCellsData[0].length;\n  return viewCellsData[rowIndex][columnIndex];\n};\n\nvar autoScroll = function autoScroll(clientOffset, scrollingStrategy) {\n  scroll(clientOffset.y, scrollingStrategy.topBoundary, scrollingStrategy.bottomBoundary, scrollingStrategy.changeVerticalScroll);\n  scroll(clientOffset.x, scrollingStrategy.leftBoundary, scrollingStrategy.rightBoundary, scrollingStrategy.changeHorizontalScroll);\n};\n\nvar scroll = function scroll(offset, firstBoundary, secondBoundary, changeScroll) {\n  if (offset < firstBoundary + SCROLL_OFFSET && offset > firstBoundary) {\n    changeScroll(-SCROLL_SPEED_PX);\n  }\n\n  if (secondBoundary - SCROLL_OFFSET < offset) {\n    changeScroll(+SCROLL_SPEED_PX);\n  }\n};\n\nvar timeBoundariesByResize = function timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart) {\n  if (targetType !== payload.appointmentType) {\n    return {\n      appointmentStartTime: undefined,\n      appointmentEndTime: undefined\n    };\n  }\n\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var sourceType = payload.type;\n\n  if (sourceType === RESIZE_TOP) {\n    var insideTopOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n    appointmentStartTime = moment(targetData.startDate).add(insideTopOffset, SECONDS).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  if (sourceType === RESIZE_BOTTOM) {\n    var insideBottomOffset = insidePart === 0 && targetType === VERTICAL_TYPE ? cellDurationMinutes * 60 / 2 : 0;\n    appointmentEndTime = moment(targetData.endDate).add(-insideBottomOffset, SECONDS).toDate();\n    appointmentStartTime = moment(payload.startDate).toDate();\n  } // keep origin appointment duration if coordinates are wrong\n\n\n  if (moment(appointmentEndTime).diff(appointmentStartTime, MINUTES) < 1) {\n    appointmentStartTime = moment(payload.startDate).toDate();\n    appointmentEndTime = moment(payload.endDate).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime\n  };\n};\n\nvar timeBoundariesByDrag = function timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  if (targetType === HORIZONTAL_TYPE && intervalDuration(payload, SECONDS) < intervalDuration(targetData, SECONDS)) {\n    return {\n      appointmentStartTime: targetData.startDate,\n      appointmentEndTime: targetData.endDate,\n      offsetTimeTop: 0\n    };\n  }\n\n  var offsetTimeTop;\n  var appointmentStartTime;\n  var appointmentEndTime;\n  var insideOffset = calculateInsideOffset(targetType, insidePart, cellDurationMinutes);\n  var start = moment(targetData.startDate).add(insideOffset, SECONDS);\n\n  if (offsetTimeTopBase === null) {\n    offsetTimeTop = moment(targetData.startDate).diff(payload.startDate, SECONDS) + insideOffset;\n  } else {\n    offsetTimeTop = offsetTimeTopBase;\n  }\n\n  if (payload.type === targetType) {\n    var appointmentDurationSeconds = intervalDuration(payload, SECONDS);\n    appointmentStartTime = moment(start).add(offsetTimeTop * -1, SECONDS).toDate();\n    appointmentEndTime = moment(start).add(appointmentDurationSeconds - offsetTimeTop, SECONDS).toDate();\n  } else {\n    appointmentStartTime = moment(targetData.startDate).add(insideOffset, SECONDS).toDate();\n    appointmentEndTime = moment(targetData.endDate).add(insideOffset, SECONDS).toDate();\n  }\n\n  return {\n    appointmentStartTime: appointmentStartTime,\n    appointmentEndTime: appointmentEndTime,\n    offsetTimeTop: offsetTimeTop\n  };\n};\n\nvar calculateAppointmentTimeBoundaries = function calculateAppointmentTimeBoundaries(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) {\n  var isDragging = payload.type === VERTICAL_TYPE || payload.type === HORIZONTAL_TYPE;\n  return isDragging ? timeBoundariesByDrag(payload, targetData, targetType, cellDurationMinutes, insidePart, offsetTimeTopBase) : timeBoundariesByResize(payload, targetData, targetType, cellDurationMinutes, insidePart);\n};\n\nvar calculateInsidePart = function calculateInsidePart(top, timeTableCellsRects, timeTableIndex) {\n  if (timeTableIndex !== undefined && timeTableIndex !== -1) {\n    var cellRect = timeTableCellsRects[timeTableIndex]();\n    return top > cellRect.top + cellRect.height / 2 ? 1 : 0;\n  }\n\n  return 0;\n};\n\nvar calculateDraftAppointments = function calculateDraftAppointments(allDayIndex, draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, targetType, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate) {\n  if (allDayIndex !== -1 || targetType === VERTICAL_TYPE && getAllDayCellsElementRects.getCellRects.length && intervalDuration(draftAppointments[0].dataItem, HOURS) > 23) {\n    var allDayDrafts = draftAppointments.map(function (draftAppt) {\n      return _assign(_assign({}, draftAppt), {\n        allDay: true\n      });\n    });\n    return {\n      allDayDraftAppointments: allDayRects(allDayDrafts, startViewDate, endViewDate, excludedDays, viewCellsData, getAllDayCellsElementRects, grouping, resources, groups, groupOrientation, groupedByDate),\n      timeTableDraftAppointments: []\n    };\n  }\n\n  if (targetType === VERTICAL_TYPE || allDayIndex !== -1) {\n    return {\n      allDayDraftAppointments: [],\n      timeTableDraftAppointments: verticalTimeTableRects(draftAppointments, startViewDate, endViewDate, excludedDays, viewCellsData, cellDurationMinutes, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n    };\n  }\n\n  return {\n    allDayDraftAppointments: [],\n    timeTableDraftAppointments: horizontalTimeTableRects(draftAppointments, startViewDate, endViewDate, viewCellsData, getTableCellElementRects, grouping, resources, groups, groupOrientation, groupedByDate)\n  };\n};\n\nvar calculateAppointmentGroups = function calculateAppointmentGroups(cellGroupingInfo, resources, appointmentData) {\n  if (!cellGroupingInfo) return {};\n  return cellGroupingInfo.reduce(function (acc, group) {\n    var _a;\n\n    var isMultipleResource = resources.find(function (resource) {\n      return resource.fieldName === group.fieldName;\n    }).allowMultiple;\n    return _assign(_assign({}, acc), (_a = {}, _a[group.fieldName] = isMultipleResource ? updateMultipleResourceInfo(group, appointmentData) : group.id, _a));\n  }, {});\n};\n\nvar updateMultipleResourceInfo = function updateMultipleResourceInfo(cellResource, appointmentData) {\n  var appointmentGroupItems = appointmentData[cellResource.fieldName];\n\n  if (appointmentGroupItems.findIndex(function (groupItem) {\n    return groupItem === cellResource.id;\n  }) !== -1) {\n    return appointmentGroupItems;\n  }\n\n  return [cellResource.id];\n};\n\nvar appointmentDragged = function appointmentDragged(start, startPrev, end, endPrev, groupingInfo, groupingInfoPrev) {\n  if (moment(start).isSame(startPrev) && moment(end).isSame(endPrev) && groupingInfoNotChanged(groupingInfo, groupingInfoPrev)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar groupingInfoNotChanged = function groupingInfoNotChanged(groupingInfo, groupingInfoPrev) {\n  var fields = Object.getOwnPropertyNames(groupingInfo);\n  return fields.every(function (field) {\n    if (Array.isArray(groupingInfo[field]) && Array.isArray(groupingInfoPrev[field])) {\n      return groupingInfo[field].every(function (item, index) {\n        return item === groupingInfoPrev[field][index];\n      });\n    }\n\n    return groupingInfo[field] === groupingInfoPrev[field];\n  });\n};\n\nvar isMonthCell = function isMonthCell(otherMonth) {\n  return otherMonth !== undefined;\n};\n\nvar isShadedAppointment = function isShadedAppointment(_a, currentTime, shadePreviousAppointments) {\n  var appointmentData = _a.data;\n  var momentCurrentDate = moment(currentTime);\n\n  if (appointmentData.allDay) {\n    return momentCurrentDate.isAfter(appointmentData.endDate, 'day') && shadePreviousAppointments;\n  }\n\n  if (momentCurrentDate.isAfter(appointmentData.endDate)) {\n    return shadePreviousAppointments;\n  }\n\n  return false;\n};\n\nvar getCurrentTimeIndicatorTop = function getCurrentTimeIndicatorTop(cellData, currentTime) {\n  var top = (currentTime - cellData.startDate.getTime()) * 100 / (cellData.endDate.getTime() - cellData.startDate.getTime());\n  return top < 0 || top > 100 ? undefined : top + \"%\";\n};\n\nvar isCellShaded = function isCellShaded(_a, currentTime, shadePreviousCells) {\n  var startDate = _a.startDate,\n      endDate = _a.endDate,\n      otherMonth = _a.otherMonth;\n  var monthCell = isMonthCell(otherMonth);\n  return (startDate.getTime() < currentTime && !monthCell || endDate.getTime() < currentTime && monthCell) && shadePreviousCells;\n};\n\nvar getAppointmentResources = function getAppointmentResources(appointment, resources, plainResources) {\n  if (!resources || resources.length === 0 || !plainResources || plainResources.length === 0) return [];\n  return resources.reduce(function (acc, resource) {\n    var appointmentResourceId = appointment[resource.fieldName];\n    if (appointmentResourceId === undefined) return acc;\n\n    if (resource.allowMultiple && !Array.isArray(appointmentResourceId) || !resource.allowMultiple && Array.isArray(appointmentResourceId)) {\n      // throw error\n      return acc;\n    }\n\n    if (resource.allowMultiple) {\n      return __spread(acc, appointmentResourceId.reduce(function (prevResources, itemId) {\n        return addResourceToAppointmentResources(plainResources, prevResources, resource, itemId);\n      }, []));\n    }\n\n    return addResourceToAppointmentResources(plainResources, acc, resource, appointmentResourceId);\n  }, []);\n};\n\nvar addResourceToAppointmentResources = function addResourceToAppointmentResources(plainResources, appointmentResources, resource, resourceId) {\n  var currentResource = plainResources.find(function (plainItem) {\n    return resource.fieldName === plainItem.fieldName && plainItem.id === resourceId;\n  });\n  return currentResource ? __spread(appointmentResources, [currentResource]) : appointmentResources;\n};\n\nvar convertResourcesToPlain = function convertResourcesToPlain(validResources) {\n  return validResources.reduce(function (acc, resource) {\n    return __spread(acc, resource.instances.map(function (item) {\n      return item;\n    }));\n  }, []);\n};\n\nvar validateResources = function validateResources(resources, mainResourceName, palette) {\n  var isMainResourceDefined = !!mainResourceName;\n  var currentPaletteIndex = 0;\n  return resources.map(function (resource, groupIndex) {\n    var fieldName = resource.fieldName;\n    var isMain = isMainResourceDefined && mainResourceName === fieldName || groupIndex === 0 && !isMainResourceDefined;\n    var title = resource.title || fieldName;\n    var allowMultiple = !!resource.allowMultiple;\n    return {\n      fieldName: fieldName,\n      isMain: isMain,\n      title: title,\n      allowMultiple: allowMultiple,\n      instances: resource.instances.map(function (resourceItem) {\n        var color = resourceItem.color || palette[currentPaletteIndex % palette.length];\n        if (!resourceItem.color) currentPaletteIndex += 1;\n        return {\n          id: resourceItem.id,\n          color: color,\n          fieldName: fieldName,\n          text: resourceItem.text || title || fieldName,\n          title: title,\n          allowMultiple: allowMultiple,\n          isMain: isMain\n        };\n      })\n    };\n  });\n};\n\nvar addResourcesToAppointments = function addResourcesToAppointments(appointments, resources, plainResources) {\n  return [appointments.map(function (appointment) {\n    return _assign(_assign({}, appointment), {\n      resources: getAppointmentResources(appointment.dataItem, resources, plainResources)\n    });\n  })];\n};\n\nvar toggleExpandedGroups = function toggleExpandedGroups(state, _a) {\n  var groupKey = _a.groupKey;\n  var expandedGroups = slice(state.expandedGroups);\n  var groupKeyIndex = expandedGroups.indexOf(groupKey);\n\n  if (groupKeyIndex > -1) {\n    expandedGroups.splice(groupKeyIndex, 1);\n  } else {\n    expandedGroups.push(groupKey);\n  }\n\n  return {\n    expandedGroups: expandedGroups\n  };\n};\n\nvar getDayScaleCellColSpan = function getDayScaleCellColSpan(cellsData) {\n  var firstDate = cellsData[0][0].startDate;\n  var count = 1;\n\n  while (cellsData[0][count] && moment(cellsData[0][count].startDate).isSame(firstDate, 'day')) {\n    count += 1;\n  }\n\n  return count;\n};\n\nvar getDayScaleCells = function getDayScaleCells(cellsData, groupedByDate) {\n  if (!groupedByDate) {\n    return cellsData[0].map(function (_a, index) {\n      var startDate = _a.startDate,\n          endDate = _a.endDate,\n          today = _a.today,\n          endOfGroup = _a.endOfGroup,\n          groupingInfo = _a.groupingInfo;\n      return {\n        key: index.toString(),\n        startDate: startDate,\n        endDate: endDate,\n        today: today,\n        endOfGroup: endOfGroup,\n        groupingInfo: groupingInfo\n      };\n    });\n  }\n\n  var prevDate;\n  var colSpan = getDayScaleCellColSpan(cellsData);\n  return cellsData[0].reduce(function (acc, _a, index) {\n    var startDate = _a.startDate,\n        endDate = _a.endDate,\n        today = _a.today;\n    var currentDate = moment(startDate);\n\n    if (currentDate.isSame(prevDate)) {\n      return acc;\n    }\n\n    prevDate = currentDate;\n    return __spread(acc, [{\n      key: index.toString(),\n      startDate: startDate,\n      endDate: endDate,\n      today: today,\n      colSpan: colSpan,\n      endOfGroup: true\n    }]);\n  }, []);\n};\n\nvar isAllDayElementsMetaActual = function isAllDayElementsMetaActual(viewCellsData, allDayElementsMeta, groupOrientation, groupCount) {\n  var numberOfRows = groupOrientation === HORIZONTAL_GROUP_ORIENTATION ? 1 : groupCount;\n  return isElementsMetaActual(viewCellsData, allDayElementsMeta, numberOfRows);\n};\n\nvar isTimeTableElementsMetaActual = function isTimeTableElementsMetaActual(viewCellsData, timeTableElementsMeta) {\n  return isElementsMetaActual(viewCellsData, timeTableElementsMeta, viewCellsData.length);\n};\n\nvar isElementsMetaActual = function isElementsMetaActual(viewCellsData, elementsMeta, numberOfRows) {\n  if (!(elementsMeta === null || elementsMeta === void 0 ? void 0 : elementsMeta.getCellRects)) {\n    return false;\n  }\n\n  var tableSize = numberOfRows * viewCellsData[0].length;\n  return tableSize === elementsMeta.getCellRects.length;\n};\n\nvar navigateByOneMonth = function navigateByOneMonth(currentDate, isBackward) {\n  return moment(currentDate)[isBackward ? 'subtract' : 'add'](1, 'month').toDate();\n};\n/** @internal */\n\n\nvar RecurrenceFrequency;\n\n(function (RecurrenceFrequency) {\n  RecurrenceFrequency[RecurrenceFrequency[\"Daily\"] = RRULE_REPEAT_TYPES.DAILY] = \"Daily\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Weekly\"] = RRULE_REPEAT_TYPES.WEEKLY] = \"Weekly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Monthly\"] = RRULE_REPEAT_TYPES.MONTHLY] = \"Monthly\";\n  RecurrenceFrequency[RecurrenceFrequency[\"Yearly\"] = RRULE_REPEAT_TYPES.YEARLY] = \"Yearly\";\n})(RecurrenceFrequency || (RecurrenceFrequency = {}));\n\nexport { APRIL_DATE, AUGUST_DATE, AUTO_HEIGHT, BASIC_DAILY_COUNT, BASIC_MONTHLY_COUNT, BASIC_WEEKLY_COUNT, BASIC_YEALY_COUNT, CANCEL_BUTTON, CANCEL_COMMAND_BUTTON, CLOSE_COMMAND_BUTTON, COMMIT_COMMAND_BUTTON, DAYS_IN_WEEK, DAYS_OF_WEEK, DAYS_OF_WEEK_ARRAY, DAYS_OF_WEEK_DATES, DAY_LONG_MONTH_LONG_YEAR_OPTIONS, DAY_LONG_MONTH_OPTIONS, DAY_OPTIONS, DAY_SHORT_MONTH_LONG_YEAR_OPTIONS, DAY_SHORT_MONTH_OPTIONS, DAY_SHORT_MONTH_SHORT_YEAR_OPTIONS, DECEMBER_DATE, DEFAULT_RULE_OBJECT, DELETE_BUTTON, DELETE_COMMAND_BUTTON, EMPTY_OPTIONS, END_REPEAT_RADIO_GROUP, FEBRUARY_DATE, FIRST_WEEK, FOURTH_WEEK, FRIDAY_DATE, HORIZONTAL_GROUP_ORIENTATION, HORIZONTAL_TYPE, HORIZONTAL_VIEW_LEFT_OFFSET, HOURS, HOUR_MINUTE_OPTIONS, JANUARY_DATE, JULY_DATE, JUNE_DATE, LAST_WEEK, LONG_MONTH_OPTIONS, LONG_WEEK_DAY_OPTIONS, MARCH_DATE, MAY_DATE, MINUTES, MONDAY_DATE, MONTHLY_RADIO_GROUP, MONTHS, MONTHS_DATES, MONTH_YEAR_OPTIONS, MULTILINE_TEXT_EDITOR, NOVEMBER_DATE, NUMBER_EDITOR, OCTOBER_DATE, OPEN_COMMAND_BUTTON, ORDINARY_LABEL, ORDINARY_TEXT_EDITOR, OUTLINED_SELECT, POSITION_END, POSITION_START, RECURRENCE_EDIT_SCOPE, REPEAT_TYPES, REPEAT_TYPES_ARRAY, RESIZE_BOTTOM, RESIZE_TOP, RRULE_REPEAT_TYPES, RecurrenceFrequency, SATURDAY_DATE, SAVE_BUTTON, SCROLL_OFFSET, SCROLL_SPEED_PX, SECONDS, SECOND_WEEK, SEPTEMBER_DATE, SHORT_MONTH_LONG_YEAR_OPTIONS, SHORT_MONTH_OPTIONS, SHORT_MONTH_SHORT_YEAR_OPTIONS, STANDARD_SELECT, SUNDAY_DATE, THIRD_WEEK, THURSDAY_DATE, TITLE, TITLE_TEXT_EDITOR, TOGGLE_APPOINTMENT_FORM_VISIBILITY, TOGGLE_APPOINTMENT_TOOLTIP_VISIBILITY, TUESDAY_DATE, VERTICAL_GROUP_ORIENTATION, VERTICAL_TYPE, VERTICAL_VIEW_LEFT_OFFSET, VIEW_TYPES, WEDNESDAY_DATE, WEEKDAY_INTERVAL, WEEK_DAY_OPTIONS, WEEK_NUMBER_LABELS, YEARLY_RADIO_GROUP, addAppointment, addGroupInfoToCell, addGroupInfoToCells, addResourcesToAppointments, adjustAppointments, allDayCells, allDayCellsData, allDayPredicate, allDayRects, appointmentDragged, appointments, areDatesSame, autoScroll, availableViews, calculateAllDayDateIntervals, calculateAppointmentGroups, calculateAppointmentTimeBoundaries, calculateDraftAppointments, calculateFirstDateOfWeek, calculateInsidePart, calculateMonthDateIntervals, calculateRectByDateAndGroupIntervals, calculateWeekDateIntervals, callActionIfExists, cancelAddedAppointment, cancelChanges, cellData, cellIndex, cellType, changeAppointment, changeCurrentDate, changeRecurrenceFrequency, changeRecurrenceOptions, changedAppointmentById, checkCellGroupingInfo, checkIsNaturalNumber, checkMultipleResourceFields, computed, convertResourcesToPlain, convertToMoment, dayBoundaryPredicate, dayScale, deleteAll, deleteCurrent, deleteCurrentAndFollowing, editAll, editCurrent, editCurrentAndFollowing, endViewDate, excludedIntervals, expandGroupedAppointment, expandGroups, expandViewCellsDataWithGroups, filterByViewBoundaries, filterResourcesByGrouping, findOverlappedAppointments, formatDateTimeGetter, formatDateToString, getAllDayCellIndexByAppointmentData, getAllDayHorizontallyGroupedColumnIndex, getAllDayVerticallyGroupedColumnIndex, getAllDayVerticallyGroupedRowIndex, getAppointmentResources, getAppointmentStyle, getAvailableRecurrenceOptions, getCellKey, getCountDependingOnRecurrenceType, getCurrentTimeIndicatorTop, getDayScaleCellColSpan, getDayScaleCells, getDaysOfWeek, getDaysOfWeekArray, getDaysOfWeekDates, getFrequencyString, getGroupFromResourceInstance, getGroupingInfoFromGroups, getGroupsFromResources, getHorizontalRectByAppointmentData, getLabelsForAllGroups, getMonthCellIndexByAppointmentData, getMonthHorizontallyGroupedColumnIndex, getMonthVerticallyGroupedRowIndex, getMonths, getMonthsWithOf, getRRuleFrequency, getRRuleSetWithExDates, getRadioGroupDisplayData, getRecurrenceOptions, getRowFromGroups, getUTCDate, getVerticalCellIndexByAppointmentData, getVerticalRectByAppointmentData, getVerticalRowFromGroups, getViewType, getWeekHorizontallyGroupedColumnIndex, getWeekHorizontallyGroupedRowIndex, getWeekNumberLabels, getWeekVerticallyGroupedColumnIndex, getWeekVerticallyGroupedRowIndex, groupAppointments, handleChangeFrequency, handleStartDateChange, handleToDayOfWeekChange, handleWeekDaysChange, handleWeekNumberChange, horizontalTimeTableRects, intervalDuration, isAllDayCell, isAllDayElementsMetaActual, isCellShaded, isDateValid, isMidnight$1 as isMidnight, isMonthCell, isShadedAppointment, isTimeTableElementsMetaActual, monthCellsData, navigateByOneMonth, normalizeAppointmentDuration, preCommitChanges, rearrangeResources, reduceAppointmentByDayBounds, setAppointmentData, setAppointmentMeta, setCurrentViewName, sliceAppointmentByDay, sliceAppointmentByWeek, sliceAppointmentsByBoundaries, sliceAppointmentsByDays, sortAppointments, sortFilteredResources, startEditAppointment, startViewDate, stopEditAppointment, timeBoundariesByDrag, timeBoundariesByResize, timeScale, toPercentage, toggleExpandedGroups, unwrapGroups, updateGroupingWithMainResource, validateResources, verticalTimeTableRects, viewBoundText, viewCellsData, viewPredicate };","map":null,"metadata":{},"sourceType":"module"}